<!DOCTYPE html>
<!-- Joshua Brewster – freeware. 3-D Fractal Point Cloud (14 formulas, 8 palettes) -->
<html lang="en">
<head>
<meta charset="UTF-8">
<title>3-D Fractal Point Cloud – Full Features</title>
<style>
  body{margin:0;overflow:hidden;background:#000}
  #ui{position:absolute;top:10px;left:10px;z-index:10;background:rgba(0,0,0,.7);
      padding:8px;border-radius:6px;color:#fff;font-family:monospace;font-size:13px}
  #ui label{display:block;margin:4px 0}
  #ui hr{border:none;border-top:1px solid #555;margin:8px 0}
  #loading{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
           background:rgba(0,0,0,.8);color:#0f0;font-family:monospace;
           padding:10px 16px;border-radius:4px;z-index:20}
</style>
<script type="importmap">
  { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js" } }
</script>
</head>
<body>
<div id="ui">
  <!-- Fractal selector (14) -->
  <label>Fractal Type:
    <select id="fractalType">
      <option value="0" selected>Mandelbrot</option>
      <option value="1">Tricorn</option>
      <option value="2">Burning Ship</option>
      <option value="3">Perpendicular Mandel</option>
      <option value="4">Celtic</option>
      <option value="5">Buffalo</option>
      <option value="6">Phoenix (λ ≈ -0.5)</option>
      <option value="7">Cubic Multibrot</option>
      <option value="8">Quartic Multibrot</option>
      <option value="9">Cosine</option>
      <option value="10">Sine</option>
      <option value="11">Heart</option>
      <option value="12">Perpendicular Buffalo</option>
      <option value="13">Abs Bar</option>
    </select>
  </label>

  <!-- Color schemes (same 8) -->
  <label>Color Scheme:
    <select id="colorScheme">
      <option value="0">Violet-Cyan-White</option>
      <option value="1">Fire</option>
      <option value="2">Ice</option>
      <option value="3">Sunset</option>
      <option value="4">Forest</option>
      <option value="5">Neon</option>
      <option value="6">Grayscale</option>
      <option value="7">Inferno</option>
    </select>
  </label>

  <!-- existing UI trimmed for brevity: alpha, thresholds, clip … -->
  <label>Alpha Mode:
    <select id="alphaMode"><option value="0">Solid</option>
      <option value="1" selected>Fade In</option><option value="2">Inverse</option></select></label>
  <label>Threshold Basis:
    <select id="thresholdBasis"><option value="0">Escape Ratio</option><option value="1">Layer Index</option></select></label>
  <label>Low α Threshold:<input id="lowThresh" type="range" min="0" max="1" step="0.01" value="0.20"><span id="lowVal">0.20</span></label>
  <label>High α Threshold:<input id="highThresh" type="range" min="0" max="1" step="0.01" value="1"><span id="highVal">1.00</span></label>
  <hr>
  <label>Clip X ≤<input id="clipX" type="range" min="-2" max="2" step="0.01" value="2"><span id="clipXVal">2.00</span></label>
  <label>Clip Y ≤<input id="clipY" type="range" min="-2" max="2" step="0.01" value="2"><span id="clipYVal">2.00</span></label>
  <label>Clip Z ≤<input id="clipZ" type="range" min="0.5" max="2" step="0.01" value="2"><span id="clipZVal">2.00</span></label>
</div>
<div id="loading">Loading layers: 0 / 0</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/OrbitControls.js';

/* ------- constants (unchanged) ------- */
const gridSize=800,zMin=0,zMax=2,dz=.02,numLayers=Math.round((zMax-zMin)/dz)+1;
const ptsPerLayer=gridSize*gridSize,zoom=4,escapeR=4,maxIter=100;
const MAX_WORKERS=Math.min(navigator.hardwareConcurrency||4,8);

/* ------- UI refs ------- */
const ui={ fractal:fractalType, scheme:colorScheme, alpha:alphaMode, basis:thresholdBasis,
  low:lowThresh,high:highThresh,lowVal,highVal,
  clipX,clipY,clipZ,clipXVal,clipYVal,clipZVal,loading};

/* ------- THREE setup (identical) ------- */
const scene=new THREE.Scene();
const camera=new THREE.PerspectiveCamera(60,innerWidth/innerHeight,.1,1000);
camera.position.set(0,-zoom*1.5,zoom);
const renderer=new THREE.WebGLRenderer({antialias:false});
renderer.setSize(innerWidth,innerHeight);
renderer.getContext().disable(renderer.getContext().CULL_FACE);
document.body.appendChild(renderer.domElement);
const controls=new OrbitControls(camera,renderer.domElement);controls.enableDamping=true;

/* ------- geometry buffers ------- */
const totalPts=ptsPerLayer*numLayers;
const posBuf=new Float32Array(totalPts*3),ratBuf=new Float32Array(totalPts),lyrBuf=new Float32Array(totalPts);
const geom=new THREE.BufferGeometry();
geom.setAttribute('position',new THREE.BufferAttribute(posBuf,3));
geom.setAttribute('ratio',new THREE.BufferAttribute(ratBuf,1));
geom.setAttribute('layerIdx',new THREE.BufferAttribute(lyrBuf,1));
geom.setDrawRange(0,0);

/* ------- uniforms & shaders  – same as before  ------- */
const uniforms={lowT:{value:+ui.low.value},highT:{value:+ui.high.value},
  alphaMode:{value:+ui.alpha.value},basis:{value:+ui.basis.value},
  scheme:{value:+ui.scheme.value},clipX:{value:+ui.clipX.value},
  clipY:{value:+ui.clipY.value},clipZ:{value:+ui.clipZ.value},
  worldCell:{value:zoom/(gridSize-1)},viewport:{value:new THREE.Vector2(innerWidth,innerHeight)}};

const mat=new THREE.ShaderMaterial({transparent:true,depthTest:true,depthWrite:true,
  blending:THREE.NormalBlending,uniforms,
  vertexShader:`precision highp float;attribute float ratio,layerIdx;varying float vR,vL;varying vec3 vW;uniform float worldCell;uniform vec2 viewport;
    void main(){vR=ratio;vL=layerIdx;vW=position;vec4 mv=modelViewMatrix*vec4(position,1.0);float d=-mv.z;
      gl_PointSize=worldCell*projectionMatrix[1][1]*viewport.y/d;gl_Position=projectionMatrix*mv;}`,
  fragmentShader:`precision highp float;varying float vR,vL;varying vec3 vW;uniform float lowT,highT;uniform int alphaMode,basis,scheme;
    uniform float clipX,clipY,clipZ,worldCell;
    vec3 hsl2rgb(vec3 hsl){float H=hsl.x,S=hsl.y,L=hsl.z;float C=(1.-abs(2.*L-1.))*S;float X=C*(1.-abs(mod(H*6.,2.)-1.));float m=L-.5*C;
      vec3 rgb=(H<1./6.)?vec3(C,X,0.):(H<2./6.)?vec3(X,C,0.):(H<3./6.)?vec3(0.,C,X):(H<4./6.)?vec3(0.,X,C):(H<5./6.)?vec3(X,0.,C):vec3(C,0.,X);return rgb+m;}
    void main(){float a=1.;if(alphaMode==1)a=vR;else if(alphaMode==2)a=1.-vR;
      a*=smoothstep(clipX+worldCell,clipX,vW.x)*smoothstep(clipY+worldCell,clipY,vW.y)*smoothstep(clipZ+worldCell,clipZ,vW.z);
      float val=(basis==1?vL:vR);if(val<lowT||val>highT||a<.01)discard;float r=vR,H,L;
      if(scheme==0){H=(260.-260.*pow(r,.9))/360.;L=(10.+65.*pow(r,1.2))/100.;}
      else if(scheme==1){H=(0.+60.*r)/360.;L=(.5+.5*r);}
      else if(scheme==2){H=(200.-100.*r)/360.;L=(.3+.7*r);}
      else if(scheme==3){H=(30.+270.*r)/360.;L=(.3+.4*r);}
      else if(scheme==4){H=(120.-90.*r)/360.;L=(.2+.5*r);}
      else if(scheme==5){H=(300.-240.*r)/360.;L=(.55+.2*sin(r*3.14159));}
      else if(scheme==6){gl_FragColor=vec4(vec3(r),a);return;}
      else{H=(40.+310.*pow(r,1.3))/360.;L=(.2+.5*pow(r,.8));}
      vec3 col=hsl2rgb(vec3(H,1.,L));gl_FragColor=vec4(col,a);} `
});
scene.add(new THREE.Points(geom,mat));

/* ------- UI → uniforms ------- */
function upd(){uniforms.lowT.value=+ui.low.value;ui.lowVal.textContent=(+ui.low.value).toFixed(2);
  uniforms.highT.value=+ui.high.value;ui.highVal.textContent=(+ui.high.value).toFixed(2);
  uniforms.alphaMode.value=+ui.alpha.value;uniforms.basis.value=+ui.basis.value;uniforms.scheme.value=+ui.scheme.value;
  uniforms.clipX.value=+ui.clipX.value;ui.clipXVal.textContent=(+ui.clipX.value).toFixed(2);
  uniforms.clipY.value=+ui.clipY.value;ui.clipYVal.textContent=(+ui.clipY.value).toFixed(2);
  uniforms.clipZ.value=+ui.clipZ.value;ui.clipZVal.textContent=(+ui.clipZ.value).toFixed(2);}
[ui.low,ui.high,ui.alpha,ui.basis,ui.scheme,ui.clipX,ui.clipY,ui.clipZ].forEach(e=>e.addEventListener('input',upd));upd();

/* ---------- Worker code (14 formulas) ---------- */
const workerSrc = `
self.onmessage = e => {
  const { gridSize, k, zMin, dz, zoom, escapeR, maxIter, fractalType } = e.data;
  const N   = gridSize * gridSize;
  const pos = new Float32Array(N * 3);
  const rat = new Float32Array(N);
  const gamma = zMin + k * dz;

  let idx = 0;

  for (let i = 0; i < gridSize; i++) {
    const x0 = (i / (gridSize - 1) - 0.5) * zoom;
    for (let j = 0; j < gridSize; j++) {
      const y0 = (j / (gridSize - 1) - 0.5) * zoom;

      /* z, previous-z (for Phoenix) */
      let qx = 0, qy = 0, px = 0, py = 0;
      let iter = 0;

      while (qx*qx + qy*qy <= escapeR*escapeR && iter < maxIter) {
        const s = 1 + iter * (gamma - 1);      // slice scaling
        const a = Math.abs(qx);
        const b = Math.abs(qy);

        let nx, ny;

        switch (fractalType) {
          case 1:  // Tricorn
            nx =  qx*qx - qy*qy + x0*s;
            ny = -2*qx*qy      + y0*s;
            break;

          case 2:  // Burning Ship
            nx =  a*a - b*b + x0*s;
            ny =  2*a*b     + y0*s;
            break;

          case 3:  // Perpendicular Mandelbrot
            nx =  qx*qx - qy*qy + x0*s;
            ny = -2*a*qy        + y0*s;
            break;

          case 4:  // Celtic
            nx =  Math.abs(qx*qx - qy*qy) + x0*s;
            ny =  2*qx*qy                + y0*s;
            break;

          case 5:  // Buffalo
            nx =  Math.abs(qx*qx - qy*qy) + x0*s;
            ny = -2*qx*qy                + y0*s;
            break;

          case 6:  // Phoenix (λ = –0.5)
            nx =  qx*qx - qy*qy + x0*s - 0.5*px;
            ny =  2*qx*qy       + y0*s - 0.5*py;
            px = qx;  py = qy;
            break;

          case 7: { // Cubic Multibrot (z³ + c)
            const r2    = qx*qx + qy*qy;
            const theta = Math.atan2(qy, qx);
            const r3    = Math.pow(r2, 1.5);        // r³
            nx = r3 * Math.cos(3*theta) + x0*s;
            ny = r3 * Math.sin(3*theta) + y0*s;
            break;
          }

          case 8: { // Quartic Multibrot (z⁴ + c)
            const r2    = qx*qx + qy*qy;
            const theta = Math.atan2(qy, qx);
            const r4    = r2 * r2;                  // r⁴
            nx = r4 * Math.cos(4*theta) + x0*s;
            ny = r4 * Math.sin(4*theta) + y0*s;
            break;
          }

          case 9:  // Cosine
            nx =  Math.cos(qx) * Math.cosh(qy)  + x0*s;
            ny = -Math.sin(qx) * Math.sinh(qy)  + y0*s;
            break;

          case 10: // Sine
            nx =  Math.sin(qx) * Math.cosh(qy)  + x0*s;
            ny =  Math.cos(qx) * Math.sinh(qy)  + y0*s;
            break;

          case 11: // Heart
            nx =  qx*qx - qy*qy + x0*s;
            ny =  Math.abs(2*qx*qy) + y0*s;
            break;

          case 12: // Perpendicular Buffalo
            nx =  Math.abs(qx*qx - qy*qy) + x0*s;
            ny = -2*a*qy                 + y0*s;
            break;

          case 13: // Abs Bar (fun variant)
            nx =  a - b + x0*s;
            ny =  a + b + y0*s;
            break;

          default: // Mandelbrot
            nx = qx*qx - qy*qy + x0*s;
            ny = 2*qx*qy       + y0*s;
        }

        qx = nx;  qy = ny;
        iter++;
      }

      const base = 3*idx;
      pos[base    ] = x0;
      pos[base + 1] = y0;
      pos[base + 2] = gamma;
      rat[idx]      = iter / maxIter;
      idx++;
    }
  }

  self.postMessage({ k, pos: pos.buffer, rat: rat.buffer },
                   [pos.buffer, rat.buffer]);
};
`;
const workerURL=URL.createObjectURL(new Blob([workerSrc],{type:'application/javascript'}));

/* ------- build pool & compute ------- */
let nextK=0,done=0,show=0,started=false,curFrac=+ui.fractal.value;
function launch(){if(nextK>=numLayers)return;
  const k=nextK++,w=new Worker(workerURL);
  w.postMessage({gridSize,k,zMin,dz,zoom,escapeR,maxIter,fractalType:curFrac});
  w.onmessage = ({ data: { k, pos, rat } }) => {
  /* typed-array views of transferred buffers */
  const p = new Float32Array(pos);
  const r = new Float32Array(rat);

  const offPts = k * ptsPerLayer;

  posBuf.set(p, offPts * 3);               // xyz
  ratBuf.set(r, offPts);                   // escape ratios
  lyrBuf.fill(k / (numLayers - 1),         // normalized layer index
              offPts, offPts + ptsPerLayer);

  done++;
  ui.loading.textContent = `Loading layers: ${done} / ${numLayers}`;

  w.terminate();         // free the worker
  launch();              // start next slice if any
};
}
function compute(){posBuf.fill(0);ratBuf.fill(0);lyrBuf.fill(0);
  nextK=done=show=0;started=false;curFrac=+ui.fractal.value;
  geom.setDrawRange(0,0);ui.loading.style.display='block';
  ui.loading.textContent=`Loading layers: 0 / ${numLayers}`;
  for(let i=0;i<MAX_WORKERS;i++)launch();}
compute();ui.fractal.addEventListener('change',compute);

/* ------- animation loop & resize (unchanged) ------- */
(function anim(){requestAnimationFrame(anim);controls.update();
  if(done===numLayers){if(!started){ui.loading.style.display='none';
      geom.attributes.position.needsUpdate=geom.attributes.ratio.needsUpdate=
      geom.attributes.layerIdx.needsUpdate=true;started=true;}
    if(show<numLayers){show++;geom.setDrawRange(0,show*ptsPerLayer);} }
  renderer.render(scene,camera);}());
addEventListener('resize',()=>{camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);uniforms.viewport.value.set(innerWidth,innerHeight);});
</script>
</body>
</html>
