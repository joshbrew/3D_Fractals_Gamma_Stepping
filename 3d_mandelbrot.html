<!DOCTYPE html>
<!-- Joshua Brewster – freeware. 3-D Fractal Point Cloud (14 formulas, 8 palettes) -->
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>3-D Fractal Point Cloud – Full Features</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000
    }

    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(0, 0, 0, .7);
      padding: 8px;
      border-radius: 6px;
      color: #fff;
      font-family: monospace;
      font-size: 13px
    }

    #ui label {
      display: block;
      margin: 4px 0
    }

    #ui hr {
      border: none;
      border-top: 1px solid #555;
      margin: 8px 0
    }

    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, .8);
      color: #0f0;
      font-family: monospace;
      padding: 10px 16px;
      border-radius: 4px;
      z-index: 20
    }
  </style>
  <script type="importmap">
  { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js" } }
</script>
</head>

<body>
  <div id="ui">
    <!-- Fractal selector (14) -->
    <label>Fractal Type:
      <select id="fractalType">
        <option value="0" selected>Mandelbrot</option>
        <option value="1">Tricorn</option>
        <option value="2">Burning Ship</option>
        <option value="3">Perpendicular Mandel</option>
        <option value="4">Celtic</option>
        <option value="5">Buffalo</option>
        <option value="6">Phoenix (λ ≈ -0.5)</option>
        <option value="7">Cubic Multibrot</option>
        <option value="8">Quartic Multibrot</option>
        <option value="9">Cosine</option>
        <option value="10">Sine</option>
        <option value="11">Heart</option>
        <option value="12">Perpendicular Buffalo</option>
        <option value="13">Abs Bar</option>
        <option value="14">Quintic Multibrot (z⁵ + c)</option>
        <option value="15">Sextic Multibrot (z⁶ + c)</option>
        <option value="16">Tangent (tan z + c)</option>
        <option value="17">Exponential (exp z + c)</option>
        <option value="18">Septic Multibrot (z⁷+c)</option>
        <option value="19">Octic Multibrot (z⁸+c)</option>
        <option value="20">Inverse Mandelbrot (1/z²+c)</option>
      </select>
    </label>

    <!-- Color schemes (same 8) -->
    <label>Color Scheme:
      <select id="colorScheme">
        <option value="0">Violet-Cyan-White</option>
        <option value="1">Fire</option>
        <option value="2">Ice</option>
        <option value="3">Sunset</option>
        <option value="4">Forest</option>
        <option value="5">Neon</option>
        <option value="6">Grayscale</option>
        <option value="7">Inferno</option>
        <option value="8">Rainbow 360 °</option>
        <option value="9">Rainbow 720 °</option>
        <option value="10">Pastel Loop</option>
        <option value="11">Viridis-ish</option>
        <option value="12">Magma</option>
        <option value="13">Plasma</option>
        <option value="14">Cividis</option>
        <option value="15">Ocean</option>
        <option value="16">Midnight Blue</option>
        <option value="17">Cool-Warm Diverge</option>
      </select>
    </label>

    <!-- existing UI trimmed for brevity: alpha, thresholds, clip … -->
    <label>Alpha Mode:
      <select id="alphaMode">
        <option value="0">Solid</option>
        <option value="1" selected>Fade In</option>
        <option value="2">Inverse</option>
      </select></label>
    <label>Threshold Basis:
      <select id="thresholdBasis">
        <option value="0">Escape Ratio</option>
        <option value="1">Layer Index</option>
      </select></label>
    <label>Low α Threshold:<input id="lowThresh" type="range" min="0" max="1" step="0.01" value="0.20"><span
        id="lowVal">0.20</span></label>
    <label>High α Threshold:<input id="highThresh" type="range" min="0" max="1" step="0.01" value="1"><span
        id="highVal">1.00</span></label>
    <hr>
    <label>Clip X ≤<input id="clipX" type="range" min="-2" max="2" step="0.01" value="2"><span
        id="clipXVal">2.00</span></label>
    <label>Clip Y ≤<input id="clipY" type="range" min="-2" max="2" step="0.01" value="2"><span
        id="clipYVal">2.00</span></label>
    <label>Clip Z ≤<input id="clipZ" type="range" min="0.5" max="2" step="0.01" value="2"><span
        id="clipZVal">2.00</span></label>
  </div>
  <div id="loading">Loading layers: 0 / 0</div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/OrbitControls.js';

    /* ------- constants (unchanged) ------- */
    const gridSize = 800, zMin = 0, zMax = 2, dz = .02, numLayers = Math.round((zMax - zMin) / dz) + 1;
    const ptsPerLayer = gridSize * gridSize, zoom = 4, escapeR = 4, maxIter = 100;
    const MAX_WORKERS = Math.min(navigator.hardwareConcurrency || 4, 8);

    /* ------- UI refs ------- */
    const ui = {
      fractal: fractalType, scheme: colorScheme, alpha: alphaMode, basis: thresholdBasis,
      low: lowThresh, high: highThresh, lowVal, highVal,
      clipX, clipY, clipZ, clipXVal, clipYVal, clipZVal, loading
    };

    /* ------- THREE setup (identical) ------- */
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, .1, 1000);
    camera.position.set(0, -zoom * 1.5, zoom);
    const renderer = new THREE.WebGLRenderer({ antialias: false });
    renderer.setSize(innerWidth, innerHeight);
    renderer.getContext().disable(renderer.getContext().CULL_FACE);
    document.body.appendChild(renderer.domElement);
    const controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true;

    /* ------- geometry buffers ------- */
    const totalPts = ptsPerLayer * numLayers;
    const posBuf = new Float32Array(totalPts * 3), ratBuf = new Float32Array(totalPts), lyrBuf = new Float32Array(totalPts);
    const geom = new THREE.BufferGeometry();
    geom.setAttribute('position', new THREE.BufferAttribute(posBuf, 3));
    geom.setAttribute('ratio', new THREE.BufferAttribute(ratBuf, 1));
    geom.setAttribute('layerIdx', new THREE.BufferAttribute(lyrBuf, 1));
    geom.setDrawRange(0, 0);

    /* ------- uniforms & shaders  – same as before  ------- */
    const uniforms = {
      lowT: { value: +ui.low.value }, highT: { value: +ui.high.value },
      alphaMode: { value: +ui.alpha.value }, basis: { value: +ui.basis.value },
      scheme: { value: +ui.scheme.value }, clipX: { value: +ui.clipX.value },
      clipY: { value: +ui.clipY.value }, clipZ: { value: +ui.clipZ.value },
      worldCell: { value: zoom / (gridSize - 1) }, viewport: { value: new THREE.Vector2(innerWidth, innerHeight) }
    };

    const mat = new THREE.ShaderMaterial({
      transparent: true, depthTest: true, depthWrite: true,
      blending: THREE.NormalBlending, uniforms,
      vertexShader: /* glsl */`
precision highp float;

attribute float ratio, layerIdx;
varying   float vR, vL;
varying   vec3  vW;

uniform float worldCell;
uniform vec2  viewport;

void main () {
  vR = ratio;
  vL = layerIdx;
  vW = position;

  vec4 mv = modelViewMatrix * vec4(position, 1.0);
  float d = -mv.z;

  gl_PointSize = worldCell * projectionMatrix[1][1] * viewport.y / d;
  gl_Position  = projectionMatrix * mv;
}`,
      fragmentShader: /* glsl */`
precision highp float;

varying vec3  vW;
varying float vR, vL;

uniform float lowT, highT;
uniform int   alphaMode, basis, scheme;
uniform float clipX, clipY, clipZ, worldCell;

/* ---------- helpers ---------- */
vec3 hsl2rgb (vec3 hsl) {
  float H = hsl.x, S = hsl.y, L = hsl.z;
  float C = (1.0 - abs(2.0 * L - 1.0)) * S;
  float X = C * (1.0 - abs(mod(H * 6.0, 2.0) - 1.0));
  float m = L - 0.5 * C;
  vec3  rgb =
        (H < 1.0/6.0) ? vec3(C, X, 0.0) :
        (H < 2.0/6.0) ? vec3(X, C, 0.0) :
        (H < 3.0/6.0) ? vec3(0.0, C, X) :
        (H < 4.0/6.0) ? vec3(0.0, X, C) :
        (H < 5.0/6.0) ? vec3(X, 0.0, C) :
                         vec3(C, 0.0, X);
  return rgb + m;
}

/* disengages when slider ≈ 2.0 */
float clipGate (float coord, float cut) {
  return (cut >= 1.999)
       ? 1.0
       : smoothstep(cut, cut - worldCell, coord);
}

/* ---------- main ---------- */
void main () {
  float a = 1.0;
  if (alphaMode == 1)      a = vR;
  else if (alphaMode == 2) a = 1.0 - vR;

  /* apply X/Y/Z clip gates */
  a *= clipGate(vW.x, clipX)
     * clipGate(vW.y, clipY)
     * clipGate(vW.z, clipZ);

  float val = (basis == 1 ? vL : vR);
  if (val < lowT || val > highT || a < 0.01) discard;

  float r = vR, H, L;


      if(scheme==0){                       /* Violet-Cyan-White */
        H = (260.0 - 260.0*pow(r,0.9)) / 360.0;
        L = (10.0  + 65.0 *pow(r,1.2)) / 100.0;

      }else if(scheme==1){                 /* Fire */
        H = ( 0.0 + 60.0*r) / 360.0;
        L = 0.50 + 0.50*r;

      }else if(scheme==2){                 /* Ice */
        H = (200.0 - 100.0*r) / 360.0;
        L = 0.30 + 0.70*r;

      }else if(scheme==3){                 /* Sunset */
        H = ( 30.0 + 270.0*r) / 360.0;
        L = 0.30 + 0.40*r;

      }else if(scheme==4){                 /* Forest */
        H = (120.0 -  90.0*r) / 360.0;
        L = 0.20 + 0.50*r;

      }else if(scheme==5){                 /* Neon */
        H = (300.0 - 240.0*r) / 360.0;
        L = 0.55 + 0.20*sin(r*3.14159);

      }else if(scheme==6){                 /* Grayscale */
        gl_FragColor = vec4(vec3(r), a);
        return;

      /* --- retuned Inferno (dark purple → red → gold, no green cast) --- */
      }else if(scheme==7){
        H = (10.0 + 60.0*pow(r,1.2)) / 360.0;   // 10°→70°
        L = 0.15 + 0.75*pow(r,1.5);

      /* --- rainbow & pastel gimmicks --- */
      }else if(scheme==8){                      /* Rainbow 360° */
        H = r;
        L = 0.45 + 0.25*(1.0 - r);

      }else if(scheme==9){                      /* Rainbow 720° */
        H = mod(2.0*r, 1.0);
        L = 0.50;

      }else if(scheme==10){                     /* Pastel loop */
        H = mod(3.0*r + 0.1, 1.0);
        L = 0.65;

      }else if(scheme==11){                     /* Viridis-ish */
        H = 0.75 - 0.55*r;                      // 270°→72°
        L = 0.25 + 0.55*r*r;

      /* --- NEW darker / cooler palettes --- */
      }else if(scheme==12){                     /* Magma */
        H = (5.0 + 70.0*r) / 360.0;             // deep plum → yellow-orange
        L = 0.10 + 0.80*pow(r,1.4);

      }else if(scheme==13){                     /* Plasma */
        H = (260.0 - 260.0*r) / 360.0;          // purple → yellow
        L = 0.30 + 0.60*pow(r,0.8);

      }else if(scheme==14){                     /* Cividis */
        H = (230.0 - 160.0*r) / 360.0;          // blue-green → orange
        L = 0.25 + 0.60*r;

      }else if(scheme==15){                     /* Ocean */
        H = (200.0 + 40.0*r) / 360.0;           // teal → azure
        L = 0.20 + 0.50*r;

      }else if(scheme==16){                     /* Midnight Blue */
        H = 0.6;                               // ~250°
        L = 0.15 + 0.35*r;

      }else if(scheme==17){                     /* Cool-Warm diverging */
        H = r < 0.5
            ? mix(0.55, 0.75, r*2.0)            // cyan-blue branch
            : mix(0.02, 0.11, (r-0.5)*2.0);     // orange-red branch
        L = 0.25 + 0.55*abs(r-0.5);

      /* fallback: old Inferno-style if scheme out of range */
      }else{
        H = (40.0 + 310.0*pow(r,1.3)) / 360.0;
        L = 0.20 + 0.50*pow(r,0.8);
      }
      vec3 col = hsl2rgb(vec3(H, 1.0, L));
      gl_FragColor = vec4(col, a);
}`
    });
    const points = new THREE.Points(geom, mat);
    points.frustumCulled = false;          // keep everything visible for now
    scene.add(points);

    /* ------- UI → uniforms ------- */
    function upd() {
      uniforms.lowT.value = +ui.low.value; ui.lowVal.textContent = (+ui.low.value).toFixed(2);
      uniforms.highT.value = +ui.high.value; ui.highVal.textContent = (+ui.high.value).toFixed(2);
      uniforms.alphaMode.value = +ui.alpha.value; uniforms.basis.value = +ui.basis.value; uniforms.scheme.value = +ui.scheme.value;
      uniforms.clipX.value = +ui.clipX.value; ui.clipXVal.textContent = (+ui.clipX.value).toFixed(2);
      uniforms.clipY.value = +ui.clipY.value; ui.clipYVal.textContent = (+ui.clipY.value).toFixed(2);
      uniforms.clipZ.value = +ui.clipZ.value; ui.clipZVal.textContent = (+ui.clipZ.value).toFixed(2);
    }
    [ui.low, ui.high, ui.alpha, ui.basis, ui.scheme, ui.clipX, ui.clipY, ui.clipZ].forEach(e => e.addEventListener('input', upd)); upd();

    /* ---------- Worker code (14 formulas) ---------- */
    const workerSrc = `
self.onmessage = e => {
  const { gridSize, k, zMin, dz, zoom, escapeR, maxIter, fractalType } = e.data;
  const N   = gridSize * gridSize;
  const pos = new Float32Array(N * 3);
  const rat = new Float32Array(N);
  const gamma = zMin + k * dz;

  let idx = 0;

  for (let i = 0; i < gridSize; i++) {
    const x0 = (i / (gridSize - 1) - 0.5) * zoom;
    for (let j = 0; j < gridSize; j++) {
      const y0 = (j / (gridSize - 1) - 0.5) * zoom;

      /* z, previous-z (for Phoenix) */
      let qx = 0, qy = 0, px = 0, py = 0;
      let iter = 0;

      while (qx*qx + qy*qy <= escapeR*escapeR && iter < maxIter) {
        const s = 1 + iter * (gamma - 1);      // slice scaling
        const a = Math.abs(qx);
        const b = Math.abs(qy);

        let nx, ny;

        switch (fractalType) {
          case 1:  // Tricorn
            nx =  qx*qx - qy*qy + x0*s;
            ny = -2*qx*qy      + y0*s;
            break;

          case 2:  // Burning Ship
            nx =  a*a - b*b + x0*s;
            ny =  2*a*b     + y0*s;
            break;

          case 3:  // Perpendicular Mandelbrot
            nx =  qx*qx - qy*qy + x0*s;
            ny = -2*a*qy        + y0*s;
            break;

          case 4:  // Celtic
            nx =  Math.abs(qx*qx - qy*qy) + x0*s;
            ny =  2*qx*qy                + y0*s;
            break;

          case 5:  // Buffalo
            nx =  Math.abs(qx*qx - qy*qy) + x0*s;
            ny = -2*qx*qy                + y0*s;
            break;

          case 6:  // Phoenix (λ = –0.5)
            nx =  qx*qx - qy*qy + x0*s - 0.5*px;
            ny =  2*qx*qy       + y0*s - 0.5*py;
            px = qx;  py = qy;
            break;

          case 7: { // Cubic Multibrot (z³ + c)
            const r2    = qx*qx + qy*qy;
            const theta = Math.atan2(qy, qx);
            const r3    = Math.pow(r2, 1.5);        // r³
            nx = r3 * Math.cos(3*theta) + x0*s;
            ny = r3 * Math.sin(3*theta) + y0*s;
            break;
          }

          case 8: { // Quartic Multibrot (z⁴ + c)
            const r2    = qx*qx + qy*qy;
            const theta = Math.atan2(qy, qx);
            const r4    = r2 * r2;                  // r⁴
            nx = r4 * Math.cos(4*theta) + x0*s;
            ny = r4 * Math.sin(4*theta) + y0*s;
            break;
          }

          case 9:  // Cosine
            nx =  Math.cos(qx) * Math.cosh(qy)  + x0*s;
            ny = -Math.sin(qx) * Math.sinh(qy)  + y0*s;
            break;

          case 10: // Sine
            nx =  Math.sin(qx) * Math.cosh(qy)  + x0*s;
            ny =  Math.cos(qx) * Math.sinh(qy)  + y0*s;
            break;

          case 11: {         // Heart
            // z_{n+1} = (|Re(z_n)| + i·Im(z_n))^2 + c
            const rx = Math.abs(qx);          // ⎯ only real part
            nx = rx*rx - qy*qy + x0*s;
            ny = 2*rx*qy      + y0*s;
            break;
          }

          case 12: // Perpendicular Buffalo
            nx =  Math.abs(qx*qx - qy*qy) + x0*s;
            ny = -2*a*qy                 + y0*s;
            break;

          case 13: // Abs Bar (fun variant)
            nx =  a - b + x0*s;
            ny =  a + b + y0*s;
            break;
            
            case 14: {                        // Quintic Multibrot  (z^5 + c)
              const r2    = qx*qx + qy*qy;
              const theta = Math.atan2(qy, qx);
              const r5    = Math.pow(r2, 2.5);           // r^(5/2)
              nx = r5 * Math.cos(5*theta) + x0*s;
              ny = r5 * Math.sin(5*theta) + y0*s;
              break;
            }

            case 15: {                        // Sextic Multibrot   (z^6 + c)
              const r2    = qx*qx + qy*qy;
              const theta = Math.atan2(qy, qx);
              const r6    = r2 * r2 * r2;                   // r^3, then squared → r^6
              nx = r6 * Math.cos(6*theta) + x0*s;
              ny = r6 * Math.sin(6*theta) + y0*s;
              break;
            }

            case 16: {                        // Tangent fractal    (tan z + c)
              // tan(x+iy) = (sin2x + i sinh2y) / (cos2x + cosh2y)
              const sin2x = Math.sin(2*qx);
              const sinh2y= Math.sinh(2*qy);
              const denom = Math.cos(2*qx) + Math.cosh(2*qy) + 1e-9; // avoid /0
              nx = sin2x / denom + x0*s;
              ny = sinh2y/ denom + y0*s;
              break;
            }

            case 17: {                        // Exponential fractal (exp z + c)
              const ex = Math.exp(qx);
              nx = ex * Math.cos(qy) + x0*s;
              ny = ex * Math.sin(qy) + y0*s;
              break;
            }
            
          case 18: {                      // Septic Multibrot (z^7 + c)
            const r2    = qx*qx + qy*qy;
            const theta = Math.atan2(qy, qx);
            const r7    = Math.pow(r2, 3.5);          // r^(7/2)
            nx = r7 * Math.cos(7*theta) + x0*s;
            ny = r7 * Math.sin(7*theta) + y0*s;
            break;
          }

          case 19: {                      // Octic Multibrot (z^8 + c)
            const r2    = qx*qx + qy*qy;
            const theta = Math.atan2(qy, qx);
            const r8    = r2*r2*r2*r2;                  // r^8
            nx = r8 * Math.cos(8*theta) + x0*s;
            ny = r8 * Math.sin(8*theta) + y0*s;
            break;
          }

          case 20: {                      // Inverse Mandelbrot (1/z^2 + c)
            const r2 = qx*qx + qy*qy + 1e-9;            // avoid /0
            const denom = r2*r2;                        // (|z|²)² = |z|⁴
            nx = ( qx*qx - qy*qy)/denom + x0*s;
            ny = (-2*qx*qy)          /denom + y0*s;
            break;
          }


          default: // Mandelbrot
            nx = qx*qx - qy*qy + x0*s;
            ny = 2*qx*qy       + y0*s;
        }

        qx = nx;  qy = ny;
        iter++;
      }

      const base = 3*idx;
      pos[base    ] = x0;
      pos[base + 1] = y0;
      pos[base + 2] = gamma;
      rat[idx]      = iter / maxIter;
      idx++;
    }
  }

  self.postMessage({ k, pos: pos.buffer, rat: rat.buffer },
                   [pos.buffer, rat.buffer]);
};
`;
    const workerURL = URL.createObjectURL(new Blob([workerSrc], { type: 'application/javascript' }));

    /* ------- build pool & compute ------- */
    let nextK = 0, done = 0, show = 0, started = false, curFrac = +ui.fractal.value;
    function launch() {
      if (nextK >= numLayers) return;
      const k = nextK++, w = new Worker(workerURL);
      w.postMessage({ gridSize, k, zMin, dz, zoom, escapeR, maxIter, fractalType: curFrac });
      w.onmessage = ({ data: { k, pos, rat } }) => {
        /* typed-array views of transferred buffers */
        const p = new Float32Array(pos);
        const r = new Float32Array(rat);

        const offPts = k * ptsPerLayer;

        posBuf.set(p, offPts * 3);               // xyz
        ratBuf.set(r, offPts);                   // escape ratios
        lyrBuf.fill(k / (numLayers - 1),         // normalized layer index
          offPts, offPts + ptsPerLayer);

        done++;
        ui.loading.textContent = `Loading layers: ${done} / ${numLayers}`;

        w.terminate();         // free the worker
        launch();              // start next slice if any
      };
    }
    function compute() {
      posBuf.fill(0); ratBuf.fill(0); lyrBuf.fill(0);
      nextK = done = show = 0; started = false; curFrac = +ui.fractal.value;
      geom.setDrawRange(0, 0); ui.loading.style.display = 'block';
      ui.loading.textContent = `Loading layers: 0 / ${numLayers}`;
      for (let i = 0; i < MAX_WORKERS; i++)launch();
    }
    compute(); ui.fractal.addEventListener('change', compute);

    /* ------- animation loop & resize (unchanged) ------- */
    (function anim() {
      requestAnimationFrame(anim); controls.update();
      if (done === numLayers) {
        if (!started) {
          ui.loading.style.display = 'none';
          geom.attributes.position.needsUpdate = geom.attributes.ratio.needsUpdate =
            geom.attributes.layerIdx.needsUpdate = true; started = true;
        }
        if (show < numLayers) { show++; geom.setDrawRange(0, show * ptsPerLayer); }
      }
      renderer.render(scene, camera);
    }());
    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight); uniforms.viewport.value.set(innerWidth, innerHeight);
    });
  </script>
</body>

</html>
