<!DOCTYPE html>
<!-- Joshua Brewster ‚Äì freeware (MIT License). 3-D Fractal Point Cloud -->
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>3-D Fractal Point Cloud ‚Äì Full Features</title>
  <style>
    :root {
      --bg: #000;
      --panel: rgba(0, 0, 0, .78);
      --border: #555;
      --gap: .5rem;
      --txt: #fff;
      --accent: #0f0;
      --font: 12px/1.3 "Fira Mono", "Consolas", monospace;
    }

    * {
      box-sizing: border-box
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--txt);
      font: var(--font)
    }

    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      max-height: calc(100% - 20px);
      width: 260px;
      overflow: auto;
      padding-right: .25rem;
    }

    details {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: .6rem
    }

    summary {
      cursor: pointer;
      font-weight: 700;
      margin: -.6rem -.6rem .6rem;
      padding: .6rem
    }

    label {
      display: grid;
      /* 3-column grid row      */
      grid-template-columns: max-content minmax(0, 1fr) max-content;
      /* text | slider | value  */
      gap: .35rem;
      align-items: center;
    }

    label input[type=range] {
      width: 100%;
      /* fill the middle cell completely  */
      min-width: 0;
      /* allow shrink when panel is narrow */
    }

    label>span {
      width: 4ch;
      /* just enough for ‚Äú-2.00‚Äù */
      text-align: right;
    }

    select,
    input[type=number],
    /* --- shared geometry ------------------------------------------------ */
    input[type=range] {
      --track-h: 6px;
      /* track height              */
      --thumb-d: 14px;
      /* thumb diameter            */
      height: calc(var(--thumb-d) + 2px);
      /* enough vertical room */
    }

    /* track -------------------------------------------------------------- */
    input[type=range]::-webkit-slider-runnable-track {
      background: linear-gradient(90deg,
          var(--fill) var(--percent),
          var(--track) var(--percent));
    }

    input[type=range]::-moz-range-track {
      height: var(--track-h);
      background: var(--track);
      border-radius: 3px;
    }

    input[type=range]::-moz-range-progress {
      height: var(--track-h);
      background: var(--fill);
      border-radius: 3px;
      background-color: green;
    }

    /* thumb -------------------------------------------------------------- */
    input[type=range]::-webkit-slider-thumb,
    input[type=range]::-moz-range-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: var(--thumb-d);
      height: var(--thumb-d);
      border-radius: 50%;
      border: none;
      background: #0086ff;
    }

    input[type=range] {
      accent-color: #00c800;
    }

    fieldset {
      border: 1px solid var(--border);
      padding: .6rem;
      margin: var(--gap) 0
    }

    legend {
      padding: 0 .4rem
    }

    button {
      padding: .3rem;
      margin-top: .4rem;
      width: 100%;
      background: #222;
      border: 1px solid var(--border);
      color: var(--txt);
      cursor: pointer
    }

    button:hover {
      background: #333
    }

    hr {
      border: none;
      border-top: 1px solid var(--border);
      margin: var(--gap) 0
    }

    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, .85);
      padding: .7rem 1rem;
      border-radius: 4px;
      font-size: 14px;
      font-weight: 700;
      color: var(--accent);
      z-index: 20
    }

    select,
    input[type=number] {
      height: 20px;
      background: #111;
      /* dark but lighter than pure black      */
      color: #fff;
      /* force white text                      */
      border: 1px solid #555;
      /* same border tone as rest of panel     */
    }

    /* options inside an open dropdown (Chrome/Blink) */
    select option {
      background: #111;
      color: #fff;
    }

    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ custom scrollbar for the <div id="ui"> panel ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    #ui {
      scrollbar-width: thin;
      /* Firefox             */
      scrollbar-color: #0f0 #111;
      /* thumb  track        */
    }

    /* WebKit / Blink ----------------------------------------------------- */
    #ui::-webkit-scrollbar {
      width: 8px;
    }

    #ui::-webkit-scrollbar-track {
      background: #111;
      /* dark track          */
    }

    #ui::-webkit-scrollbar-thumb {
      background: #00c800;
      /* neon green thumb    */
      border-radius: 4px;
      border: 1px solid #0a0;
      /* subtle bevel        */
    }

    #ui::-webkit-scrollbar-thumb:hover {
      background: #1aff1a;
      /* brighter on hover   */
    }
  </style>
  <script type="importmap">
  { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js" } }
</script>
</head>

<body>
  <div id="ui">
    <details open>
      <summary>Controls ‚ñæ</summary>
      <hr>
      <!-- Color schemes -->
      <label>üé®:
        <select id="colorScheme">
          <option value="0">Violet-Cyan-White</option>
          <option value="1">Fire</option>
          <option value="2">Ice</option>
          <option value="3">Sunset</option>
          <option value="4">Forest</option>
          <option value="5">Neon</option>
          <option value="6">Grayscale</option>
          <option value="7">Inferno</option>
          <option value="8">Rainbow 360 ¬∞</option>
          <option value="9">Rainbow 720 ¬∞</option>
          <option value="10">Pastel Loop</option>
          <option value="11">Viridis-ish</option>
          <option value="12">Magma</option>
          <option value="13">Plasma</option>
          <option value="14">Cividis</option>
          <option value="15">Ocean</option>
          <option value="16">Midnight Blue</option>
          <option value="17">Cool-Warm Diverge</option>
          <option value="18">Rainbow 1080¬∞ (3 loops)</option>
          <option value="19">Rainbow 1440¬∞ (4 loops)</option>
          <option value="20">Pastel 5-loop</option>
          <option value="21">Thermal</option>
          <option value="22">Turbulent Wave</option>
          <option value="23">Autumn</option>
          <option value="24">Spring</option>
          <option value="25">Summer</option>
          <option value="26">Mono-loop (10√ó grayscale flicker)</option>
          <option value="27">High-contrast Diverging</option>
          <option value="28">Sine-wave Hue</option>
          <option value="29">Sawtooth Loop (3 loops)</option>
          <option value="30">Rainbow 2160¬∞ (6 loops)</option>
          <option value="31">Triangle-wave 8 loops</option>
          <option value="32">Exponential 12 loops</option>
          <option value="33">Sawtooth 10 loops + offset</option>
        </select>
      </label>
      <label>Hue Rotate:
        <input id="hueOffset" type="range" min="0" max="360" step="1" value="0">
        <span id="hueOffsetVal">0¬∞</span>
      </label>

      <!-- alpha, thresholds, clip ‚Ä¶ -->
      <label>Alpha Mode:
        <select id="alphaMode">
          <option value="0">Solid</option>
          <option value="1" selected>Fade In</option>
          <option value="2">Inverse</option>
        </select></label>
      <label>Threshold Basis:
        <select id="thresholdBasis">
          <option value="0">Escape Ratio</option>
          <option value="1">Layer Index</option>
        </select></label>
      <label>Low Œ± Threshold:<input id="lowThresh" type="range" min="0" max="1" step="0.01" value="0.20"><span
          id="lowVal">0.20</span></label>
      <label>High Œ± Threshold:<input id="highThresh" type="range" min="0" max="1" step="0.01" value="1"><span
          id="highVal">1.00</span></label>

      <hr>
      <label>Clip X ‚â§<input id="clipX" type="range" min="-2" max="2" step="0.01" value="2"><span
          id="clipXVal">2.00</span></label>
      <label>Clip Y ‚â§<input id="clipY" type="range" min="-2" max="2" step="0.01" value="2"><span
          id="clipYVal">2.00</span></label>
      <label>Clip Z ‚â§<input id="clipZ" type="range" min="0" max="2" step="0.01" value="2"><span
          id="clipZVal">2.00</span></label>

      <label>Visible Layers:<input id="layerVis" type="range" min="1" max="101" step="1"><span
          id="layerVal"></span></label>
      <label>Layer Offset:
        <input id="layerOffset" type="range" min="0" max="0" step="1" value="0">
        <span id="layerOffsetVal">0</span>
      </label>
      <label>Point Size √ó:<input id="ptSize" type="range" min="0.2" max="4" step="0.05" value="1"><span
          id="ptVal">1.00</span></label>
      <label>Z Spacing √ó:<input id="zScale" type="range" min="0.1" max="50" step="0.1" value="1"><span
          id="zVal">1.00</span></label>
      <hr>

      <fieldset style="border:1px solid #555;padding:6px">
        <legend>Render Parameters</legend>
        <!-- Fractal selector -->
        <label>Fractal üìê:
          <select id="fractalType">
            <option value="0" selected>Mandelbrot</option>
            <option value="20">Inverse Mandelbrot (1/z¬≤+c)</option>
            <option value="37">Inverse Tricorn (1/conj(z)¬≤ + c)</option>
            <option value="3">Perpendicular Mandel</option>
            <option value="2">Burning Ship</option>
            <option value="21">Burning Ship ‚Äì Tip Zoom</option>
            <option value="4">Celtic</option>
            <option value="5">Buffalo</option>
            <option value="6">Phoenix (Œª ‚âà -0.5)</option>
            <option value="41">Nova Mandelbrot (z¬≥ ‚àí 1, z‚ÇÄ = 0)</option>
            <option value="43">Nova 2</option>
            <option value="26">Tri-Nova</option>
            <option value="44">Quad-Nova</option>
            <option value="40">Inverse Tri-Nova</option>
            <option value="42">Inverse Tri-Nova 2</option>
            <option value="27">Man-o-War</option>
            <option value="11">Heart</option>
            <option value="9">Cosine</option>
            <option value="10">Sine</option>
            <option value="12">Perpendicular Buffalo</option>
            <option value="16">Tangent (tan z + c)</option>
            <option value="17">Exponential (exp z + c)</option>
            <option value="1">Tricorn Mandelbrot</option>
            <option value="13">Spiral Mandelbrot</option>
            <option value="7">Cubic Multibrot</option>
            <option value="8">Quartic Multibrot</option>
            <option value="14">Quintic Multibrot (z‚Åµ + c)</option>
            <option value="15">Sextic Multibrot (z‚Å∂ + c)</option>
            <option value="18">Septic Multibrot (z‚Å∑+c)</option>
            <option value="19">Octic Multibrot (z‚Å∏+c)</option>
            <option value="22">Cubic Ship (|z|¬≥ + c)</option>
            <option value="23">Quartic Ship (|z|‚Å¥ + c)</option>
            <option value="24">Quintic Ship (|z|‚Åµ + c)</option>
            <option value="25">Hexic Ship (|z|‚Å∂ + c)</option>
            <option value="30">Inverse Cubic (1 / z¬≥ + c)</option>
            <option value="31">Inverse Quartic (1 / z‚Å¥ + c)</option>
            <option value="32">Inverse Quintic (1 / z‚Åµ + c)</option>
            <option value="33">Inverse Sextic (1 / z‚Å∂ + c)</option>
            <option value="34">Inverse Septic (1 / z‚Å∑ + c)</option>
            <option value="35">Inverse Octic (1 / z‚Å∏ + c)</option>
            <option value="36">Inverse Burning Ship (1/|z|¬≤ + c)</option>
            <option value="38">Inverse Celtic (|1/z|¬≤ + c)</option>
            <option value="39">Inverse Phoenix (1/z¬≤ ‚Äì 0.5¬∑z<sub>n‚Äì1</sub> + c)</option>
            <option value="45">Quartic Flower-Nova</option>
            <option value="46">Scatter-Nova</option>
          </select>
        </label>
        <label>Grid (px):<input id="pGrid" type="number" min="100" max="1200" step="50" value="800"></label>
        <label>zMin:<input id="pZmin" type="number" step="0.01" value="0"></label>
        <label>zMax:<input id="pZmax" type="number" step="0.01" value="2"></label>
        <label>dz (step):<input id="pDz" type="number" step="0.001" value="0.02"></label>
        <label>zoom:<input id="pZoom" type="number" step="0.1" value="4"></label>
        <label>escapeR:<input id="pEsc" type="number" step="0.5" value="4"></label>
        <label>maxIter:<input id="pIter" type="number" min="10" max="1000" step="10" value="100"></label>
        <label>dx (real):<input id="pDx" type="number" step="0.001" value="0"></label>
        <label>dy (imag):<input id="pDy" type="number" step="0.001" value="0"></label>
        <label>Scale Mode:
          <select id="scaleMode">
            <option value="0">None</option>
            <option value="1" selected>Multiply</option>
            <option value="2">Divide</option>
          </select>
        </label>
        <label>Force C-test:<input id="convergence" type="checkbox"></label>
        <!--         <label>Julia Mode:
          <input id="pJuliaMode" type="checkbox">
        </label>
        <label>Julia Re:
          <input id="pJuliaRe" type="number" step="0.01" value="0.75">
        </label>
        <label>Julia Im:
          <input id="pJuliaIm" type="number" step="0.01" value="0.00">
        </label> -->
        <button id="applyParams" style="width:100%;margin-top:6px">Apply</button>
        <button id="resetAll" style="width:100%;margin-top:4px;background:#550;border-color:#777">
          Reset defaults
        </button>
      </fieldset>

    </details>
    <details>
      <summary>Key / Slider Reference ‚ñæ</summary>

      <!-- movement --------------------------------------------------------->
      <h4 style="margin:.4rem 0 0;">Navigation</h4>
      <ul style="margin:.25rem 0 .5rem 1.2rem;padding:0;list-style:square outside;">
        <li><b>W A S D</b> ‚Äì move forward / left / back / right</li>
        <li><b>Mouse Drag</b> ‚Äì orbit tumble (when not in FPS)</li>
        <li><b>Scroll Wheel</b> ‚Äì zoom in / out</li>
        <li><b>Esc</b> ‚Äì exit FPS pointer-lock</li>
      </ul>

      <!-- quick keys ------------------------------------------------------->
      <h4 style="margin:.4rem 0 0;">Quick Keys</h4>
      <ul style="margin:.25rem 0 .5rem 1.2rem;padding:0;list-style:square outside;">
        <li><b>Q / E</b> ‚Äì Low Œ± threshold (‚Üì / ‚Üë)</li>
        <li><b>F / G</b> ‚Äì High Œ± threshold</li>
        <li><b>B / N</b> ‚Äì Visible layers</li>
        <li><b>Z / X</b> ‚Äì Point size</li>
        <li><b>N / M</b> ‚Äì Z-spacing multiplier</li>
      </ul>

      <hr>
      <!-- variable meanings ----------------------------------------------->
      <h4 style="margin:.4rem 0 0;">Parameter Notes</h4>
      <dl style="margin:.25rem 0 .5rem;">
        <dt><b>Low / High Œ±</b></dt>
        <dd style="margin:0 0 .3rem 1.2rem;">Alpha fade window. Points outside are discarded.</dd>

        <dt><b>Clip X / Y / Z</b></dt>
        <dd style="margin:0 0 .3rem 1.2rem;">Spatial cutting planes (units = world-coords after scaling).</dd>

        <dt><b>Visible Layers</b></dt>
        <dd style="margin:0 0 .3rem 1.2rem;">How many slice planes are drawn (out of the total).</dd>

        <dt><b>Point Size √ó</b></dt>
        <dd style="margin:0 0 .3rem 1.2rem;">Global multiplier on per-point size in screen pixels.</dd>

        <dt><b>Z Spacing √ó</b></dt>
        <dd style="margin:0 0 .3rem 1.2rem;">Stretch/compress distance between slice planes.</dd>

        <hr>
        <h4 style="margin:.4rem 0 0;">Render Parameters</h4>
        <dl style="margin:.25rem 0 .5rem;">
          <dt><b>Grid (px)</b></dt>
          <dd style="margin:0 0 .3rem 1.2rem;">
            Number of sample points per slice (gridSize¬≤ total); larger = finer detail, slower.
          </dd>

          <dt><b>zMin / zMax</b></dt>
          <dd style="margin:0 0 .3rem 1.2rem;">
            Starting and ending slice coordinates (before&nbsp;Z&nbsp;spacing). Range 0‚Äì2 maps into full fractal
            depth.
          </dd>

          <dt><b>dz (step)</b></dt>
          <dd style="margin:0 0 .3rem 1.2rem;">
            Distance between consecutive slices in fractal space (smaller = more layers).
          </dd>

          <dt><b>zoom</b></dt>
          <dd style="margin:0 0 .3rem 1.2rem;">
            Width/height of the complex-plane window; lower values zoom in.
          </dd>

          <dt><b>escapeR</b></dt>
          <dd style="margin:0 0 .3rem 1.2rem;">
            Escape radius used in the iteration test; raise for higher-order fractals.
          </dd>

          <dt><b>maxIter</b></dt>
          <dd style="margin:0 0 .3rem 1.2rem;">
            Maximum iterations per point. Higher = sharper edges, slower render.
          </dd>

          <dt><b>dx / dy</b></dt>
          <dd style="margin:0 0 .3rem 1.2rem;">
            Real and imaginary offset of the fractal window (pans the view).
          </dd>

          <dt><b>Force C-Test</b></dt>
          <dd style="margin:0 0 .3rem 1.2rem;">
            Force convergence testing, punches holes in standard fractals. It runs on Nova fractals for performance.
          </dd>
        </dl>
      </dl>
    </details>
  </div>
  <div id="loading">Loading layers: 0 / 0</div>
  <script>
    function paintRange(el) {
      const pct = 100 * (el.value - el.min) / (el.max - el.min);
      el.style.setProperty('--percent', pct + '%');
    }
    document.querySelectorAll('#ui input[type=range]').forEach(slider => {
      paintRange(slider);                    // initial paint
      slider.addEventListener('input', () => paintRange(slider));
    });

  </script>

  <script type="module">
    /* ---------- Worker code (14 formulas) ---------- */
    const workerSrc = `

self.onmessage = e => {
    const {
        gridSize, k, zMin, dz, zoom, escapeR,
        maxIter, fractalType, dx = 0, dy = 0,
        juliaMode, juliaRe = 0.75, juliaIm = 0,
        epsilon: epsIn = 1e-6, scaleMode = 1, convergenceTest
    } = e.data;

    const N = gridSize * gridSize;
    const pos = new Float32Array(N * 3);
    const rat = new Float32Array(N);
    const gamma = zMin + k * dz;
    const epsilon = epsIn * zoom;
    const invGrid = 1 / (gridSize - 1);
    const escapeR2 = escapeR * escapeR;

    const isNewton =
        fractalType === 26  || // Nova
        fractalType === 40  || // Tri-Nova
        fractalType === 41  || // Nova-Mandelbrot
        fractalType === 42  || // Nova-2
        fractalType === 43  || // Nova-2 (alt)
        fractalType === 44  || // Quartic-Nova
        fractalType === 45  || // Flower-Nova
        fractalType === 46;    // Scatter-Nova

    let idx = 0;
    for (let i = 0; i < gridSize; i++) {
        const x0 = juliaMode
            ? juliaRe
            : ((i * invGrid - 0.5) * zoom + dx);

        for (let j = 0; j < gridSize; j++) {
            const y0 = juliaMode
                ? juliaIm
                : ((j * invGrid - 0.5) * zoom + dy);

            let [qx, qy, px, py] = getInitialZ(fractalType, x0, y0);
            let iter = 0;

            outer:
            while (qx * qx + qy * qy <= escapeR2 && iter < maxIter) {
                const { nx, ny, npx, npy } =
                    computeFractal(fractalType, qx, qy, px, py, x0, y0, gamma, iter, scaleMode);

                // convergence test
                const dx_ = nx - qx, dy_ = ny - qy;
                if ((isNewton || convergenceTest) && dx_ * dx_ + dy_ * dy_ < epsilon) {
                    qx = nx; qy = ny;
                    iter++;
                    break outer;
                }
                qx = nx; qy = ny;
                px = npx; py = npy;
                iter++;
            }

            const b = 3 * idx++;
            pos[b] = x0;
            pos[b + 1] = y0;
            pos[b + 2] = gamma;
            rat[idx - 1] = iter / maxIter;
        }
    }

    self.postMessage({ k, pos: pos.buffer, rat: rat.buffer },
        [pos.buffer, rat.buffer]);
};


/* ---------- Burning-Ship Multibrot helpers ---------- */
function shipPower(ax, ay, p) {           // |z|^p in polar coords
    // r = sqrt(ax¬≤+ay¬≤)  ;  Œ∏ = atan2(ay, ax)
    const r2 = ax * ax + ay * ay;
    const r = Math.pow(r2, 0.5 * p);      // r^p
    const th = Math.atan2(ay, ax) * p;     // pŒ∏
    return [r * Math.cos(th),               // Re part
    r * Math.sin(th)];             // Im part
}

/* ---------- generic inverse-power helper ---------- */
function invPower(qx, qy, p) {
    /* 1 / (qx + i qy)^p  via polar form */
    const r2 = qx * qx + qy * qy + 1e-9;        // avoid /0
    const rp = Math.pow(r2, p * 0.5);       // r^p
    const th = Math.atan2(qy, qx) * p;      // p¬∑Œ∏
    const rpInv = 1.0 / rp;                 // 1 / r^p
    return [rpInv * Math.cos(th),          // Re
    -rpInv * Math.sin(th)];       // Im  (negated ‚áí 1/z^p)
}

function getInitialZ(type, x0, y0) {
    if (type === 41) return [1, 0, 0, 0];   // Nova starts at 1+0i, px=py=0
    if (type >= 30 && type <= 39) return [x0, y0, 0, 0]; // inverse families at c
    return [0, 0, 0, 0];                            // all others at 0
}

function computeFractal(fractalType, qx, qy, px, py, cx, cy, gamma, iter, scaleMode=1) {
    const s = 1 + iter * (gamma - 1);
    let ccx = cx, ccy = cy;
    if(scaleMode === 1){
        ccx*=s; ccy*=s;
    } else if (scaleMode === 2) {
        ccx/=s; ccy/=s;
    }
    const a = Math.abs(qx), b = Math.abs(qy);
    let nx, ny, npx = px, npy = py;
    

    switch (fractalType) {
        case 1:  // Tricorn
            nx = qx * qx - qy * qy + ccx;
            ny = -2 * qx * qy + ccy;
            break;

        case 2:  // Burning Ship
            nx = a * a - b * b + ccx;
            ny = 2 * a * b + ccy;
            break;

        case 3:  // Perpendicular Mandelbrot
            nx = qx * qx - qy * qy + ccx;
            ny = -2 * a * qy + ccy;
            break;

        case 4:  // Celtic
            nx = Math.abs(qx * qx - qy * qy) + ccx;
            ny = 2 * qx * qy + ccy;
            break;

        case 5:  // Buffalo
            nx = Math.abs(qx * qx - qy * qy) + ccx;
            ny = -2 * qx * qy + ccy;
            break;

        case 6:  // Phoenix (Œª = ‚Äì0.5)
            nx   = qx*qx - qy*qy + ccx - 0.5*px;
            ny   = 2*qx*qy    + ccy - 0.5*py;
            npx  = qx;      // ‚Üê store *this* iteration's z for the next round
            npy  = qy;
            break;

        case 7: { // Cubic Multibrot (z¬≥ + c)
            const r2 = qx * qx + qy * qy;
            const theta = Math.atan2(qy, qx);
            const r3 = Math.pow(r2, 1.5);        // r¬≥
            nx = r3 * Math.cos(3 * theta) + ccx;
            ny = r3 * Math.sin(3 * theta) + ccy;
            break;
        }

        case 8: { // Quartic Multibrot (z‚Å¥ + c)
            const r2 = qx * qx + qy * qy;
            const theta = Math.atan2(qy, qx);
            const r4 = r2 * r2;                  // r‚Å¥
            nx = r4 * Math.cos(4 * theta) + ccx;
            ny = r4 * Math.sin(4 * theta) + ccy;
            break;
        }

        case 9:  // Cosine
            nx = Math.cos(qx) * Math.cosh(qy) + ccx;
            ny = -Math.sin(qx) * Math.sinh(qy) + ccy;
            break;

        case 10: // Sine
            nx = Math.sin(qx) * Math.cosh(qy) + ccx;
            ny = Math.cos(qx) * Math.sinh(qy) + ccy;
            break;

        case 11: {         // Heart
            // z_{n+1} = (|Re(z_n)| + i¬∑Im(z_n))^2 + c
            const rx = Math.abs(qx);          // ‚éØ only real part
            nx = rx * rx - qy * qy + ccx;
            ny = 2 * rx * qy + ccy;
            break;
        }

        case 12: // Perpendicular Buffalo
            nx = Math.abs(qx * qx - qy * qy) + ccx;
            ny = -2 * a * qy + ccy;
            break;

        /* -------- Spiral Mandelbrot (simple quadratic with a twist) ----------------- */
        case 13: {
            const THETA = 0.35 + 2 * gamma;            // per-layer twist
            const wRe = Math.cos(THETA);
            const wIm = Math.sin(THETA);

            /* z¬≤  (= qx¬≤-qy¬≤  +  i¬∑2qxqy) */
            const zx2 = qx * qx - qy * qy;
            const zy2 = 2.0 * qx * qy;

            /* w¬∑z¬≤  (complex multiply) */
            const tx = wRe * zx2 - wIm * zy2;
            const ty = wRe * zy2 + wIm * zx2;

            nx = tx + ccx;
            ny = ty + ccy;
            break;
        }

        case 14: {                        // Quintic Multibrot  (z^5 + c)
            const r2 = qx * qx + qy * qy;
            const theta = Math.atan2(qy, qx);
            const r5 = Math.pow(r2, 2.5);           // r^(5/2)
            nx = r5 * Math.cos(5 * theta) + ccx;
            ny = r5 * Math.sin(5 * theta) + ccy;
            break;
        }

        case 15: {                        // Sextic Multibrot   (z^6 + c)
            const r2 = qx * qx + qy * qy;
            const theta = Math.atan2(qy, qx);
            const r6 = r2 * r2 * r2;                   // r^3, then squared ‚Üí r^6
            nx = r6 * Math.cos(6 * theta) + ccx;
            ny = r6 * Math.sin(6 * theta) + ccy;
            break;
        }

        case 16: {                        // Tangent fractal    (tan z + c)
            // tan(x+iy) = (sin2x + i sinh2y) / (cos2x + cosh2y)
            const sin2x = Math.sin(2 * qx);
            const sinh2y = Math.sinh(2 * qy);
            const denom = Math.cos(2 * qx) + Math.cosh(2 * qy) + 1e-9; // avoid /0
            nx = sin2x / denom + ccx;
            ny = sinh2y / denom + ccy;
            break;
        }

        case 17: {                        // Exponential fractal (exp z + c)
            const ex = Math.exp(qx);
            nx = ex * Math.cos(qy) + ccx;
            ny = ex * Math.sin(qy) + ccy;
            break;
        }

        case 18: {                      // Septic Multibrot (z^7 + c)
            const r2 = qx * qx + qy * qy;
            const theta = Math.atan2(qy, qx);
            const r7 = Math.pow(r2, 3.5);          // r^(7/2)
            nx = r7 * Math.cos(7 * theta) + ccx;
            ny = r7 * Math.sin(7 * theta) + ccy;
            break;
        }

        case 19: {                      // Octic Multibrot (z^8 + c)
            const r2 = qx * qx + qy * qy;
            const theta = Math.atan2(qy, qx);
            const r8 = r2 * r2 * r2 * r2;                  // r^8
            nx = r8 * Math.cos(8 * theta) + ccx;
            ny = r8 * Math.sin(8 * theta) + ccy;
            break;
        }

        case 20: {                      // Inverse Mandelbrot (1/z^2 + c)
            const r2 = qx * qx + qy * qy + 1e-9;   // avoid /0
            const inv = 1.0 / (r2 * r2);          // 1 / |z|‚Å¥

            // real part is unchanged
            nx = (qx * qx - qy * qy) * inv + ccx;

            // *** sign is now POSITIVE ***
            ny = (2 * qx * qy) * inv + ccy;
            break;
        }

        case 21: {   // Burning Ship  ‚Äì deep zoom on the forward tip
            /*  centre of the tiny replica (credit: Hofstadter needles list)
                approximately  (‚Äì1.7443359375 , ‚Äì0.017451171875)           */
            const cx = -1.7443359375;
            const cy = -0.017451171875;

            /* extra magnification: shrink the grid  to ~3 % of normal  */
            const sub = 0.04;                      // ‚Üê tweak to zoom further

            /* translate AND shrink the c-plane sample */
            const dx = cx*sub + cx;
            const dy = cy*sub + cy;

            nx = a * a - b * b + dx * s;               // same Burning-Ship update
            ny = 2.0 * a * b + dy * s;
            break;
        }

        case 22: {  // Cubic Burning Ship  |z|¬≥ + c
            const [rx, ry] = shipPower(a, b, 3.0);
            nx = rx + ccx;
            ny = ry + ccy;
            break;
        }

        case 23: {  // Quartic Burning Ship |z|‚Å¥ + c
            const [rx, ry] = shipPower(a, b, 4.0);
            nx = rx + ccx;
            ny = ry + ccy;
            break;
        }

        case 24: {  // Quintic Burning Ship |z|‚Åµ + c
            const [rx, ry] = shipPower(a, b, 5.0);
            nx = rx + ccx;
            ny = ry + ccy;
            break;
        }

        case 25: {  // Hexic Burning Ship  |z|‚Å∂ + c
            const [rx, ry] = shipPower(a, b, 6.0);
            nx = rx + ccx;
            ny = ry + ccy;
            break;
        }

        /* -------- Nova fractal (Newton method blend) -------------------------------- */
        case 26: {                                // z ‚àí (z¬≥ ‚àí 1)/(3 z¬≤) + c
            /* z¬≤ */
            const zx2 = qx * qx - qy * qy,
                zy2 = 2.0 * qx * qy;

            /* z¬≥ = z¬≤¬∑z */
            const zx3 = zx2 * qx - zy2 * qy,
                zy3 = zx2 * qy + zy2 * qx;

            /* numerator (z¬≥ ‚àí 1) */
            const numx = zx3 - 1.0,
                numy = zy3;

            /* denominator 3 z¬≤ */
            const denx = 3.0 * zx2,
                deny = 3.0 * zy2;
            const den2 = denx * denx + deny * deny + 1e-9;     // avoid /0

            /* (z¬≥‚àí1)/(3 z¬≤) */
            const qxDiv = (numx * denx + numy * deny) / den2;
            const qyDiv = (numy * denx - numx * deny) / den2;

            nx = qx - qxDiv + ccx;
            ny = qy - qyDiv + ccy;
            break;
        }

        /* -------- Man-o-War (needs previous-z, reuse Phoenix vars) ------------------ */
        case 27: {                                // z¬≤ + c + z_{n-1}
            nx = qx * qx - qy * qy + ccx + px;
            ny = 2.0 * qx * qy + ccy + py;
            px = qx; py = qy;                       // store prev-z
            break;
        }
        /*   30 ‚Äì inv cubic   | 31 ‚Äì inv quartic | ‚Ä¶ | 35 ‚Äì inv octic   */
        case 30:
        case 31:
        case 32:
        case 33:
        case 34:
        case 35: {
            const p = invPowerP;                        // 3 ‚Ä¶ 8
            const r2 = qx * qx + qy * qy + 1e-12;            // tiny Œµ avoids /0
            const rp = Math.pow(r2, -p * 0.5);           // 1 / r^p
            const ang = -p * Math.atan2(qy, qx);          // ‚àíp¬∑Œ∏   (minus sign = reciprocal)
            const rx = rp * Math.cos(ang);
            const ry = rp * Math.sin(ang);
            nx = rx + ccx;
            ny = ry + ccy;
            break;
        }
        /* ---------- 36 : Inverse Burning-Ship (reciprocal variant) -------- */
        case 36: {              //  1 / (|z|¬≤)      + c
            const a = Math.abs(qx), b = Math.abs(qy);
            const r2 = qx * qx + qy * qy + 1e-9;          // avoid /0
            const inv = 1.0 / (r2 * r2);                // 1 / |z|‚Å¥
            nx = (a * a - b * b) * inv + ccx;
            ny = (2 * a * b) * inv + ccy;
            break;
        }

        /* ---------- 37 : Inverse Tricorn ---------------------------------- */
        case 37: {              //  1 / (conj(z)¬≤)  + c
            const r2 = qx * qx + qy * qy + 1e-9;
            const inv = 1.0 / (r2 * r2);
            nx = (qx * qx - qy * qy) * inv + ccx;
            ny = (-2 * qx * qy) * inv + ccy;      // note minus => conjugate
            break;
        }

        /* ---------- 38 : Inverse Celtic (uses abs on real part) ------------ */
        case 38: {
            const r2 = qx * qx + qy * qy + 1e-9;
            const inv = 1.0 / (r2 * r2);
            const rx = Math.abs(qx * qx - qy * qy);
            nx = rx * inv + ccx;
            ny = (2 * qx * qy) * inv + ccy;
            break;
        }

        /* ---------- 39 : Inverse Phoenix (1/z¬≤ ‚Äì 0.5¬∑prev + c) ------------ */
        case 39: {
            const r2 = qx * qx + qy * qy + 1e-9;      // avoid /0
            const inv = 1.0 / (r2 * r2);           // 1 / |z|‚Å¥

            /* true 1 / z¬≤   (Im part is POSITIVE) */
            const zx2 = (qx * qx - qy * qy) * inv;    // Re
            const zy2 = (2.0 * qx * qy) * inv;    // Im  ‚Üê fixed sign

            nx = zx2 + ccx - 0.5 * px;              // Phoenix blend  Œª = ‚Äì0.5
            ny = zy2 + ccy - 0.5 * py;

            px = qx;                               // save previous-z
            py = qy;
            break;
        }
        case 40: { //Tri-Nova
            /* z¬≤ */
            const zx2 = qx * qx - qy * qy,
                zy2 = 2.0 * qx * qy;

            /* z‚Å¥ = (z¬≤)¬≤ */
            const zx4 = zx2 * zx2 - zy2 * zy2,
                zy4 = 2.0 * zx2 * zy2;

            /*  (4/3)¬∑z  ‚àí  (1/3)¬∑z‚Å¥  + c  */
            nx = (1.3333333333333333 * qx) - (0.3333333333333333 * zx4) + ccx;
            ny = (1.3333333333333333 * qy) - (0.3333333333333333 * zy4) + ccy;
            break;
        }
        case 41: {
            // Nova‚ÄêMandelbrot: z‚Çô‚Çä‚ÇÅ = z‚Çô ‚àí (z‚Çô¬≥ ‚àí 1)/(3 z‚Çô¬≤) + c

            // z¬≤
            const zx2 = qx * qx - qy * qy,
                zy2 = 2.0 * qx * qy;
            // z¬≥
            const zx3 = zx2 * qx - zy2 * qy,
                zy3 = zx2 * qy + zy2 * qx;
            // denominator = 3¬∑z¬≤
            const denx = 3.0 * zx2,
                deny = 3.0 * zy2;
            const den2 = denx * denx + deny * deny + 1e-9;  // avoid /0

            // numerator = z¬≥ ‚àí 1
            const numx = zx3 - 1.0,
                numy = zy3;

            // division (z¬≥‚àí1)/(3 z¬≤)
            const divx = (numx * denx + numy * deny) / den2;
            const divy = (numy * denx - numx * deny) / den2;

            // candidate for next z
            const nx0 = qx - divx + ccx,
                ny0 = qy - divy + ccy;

            // otherwise accept the step
            nx = nx0;
            ny = ny0;
            break;
        }
        case 42: {  // Nova 2
            // 1) compute 1/z
            const r2_inv = 1.0 / (qx * qx + qy * qy + 1e-9);
            const izRe = qx * r2_inv;
            const izIm = -qy * r2_inv;

            // 2) build (1/z)^2 and (1/z)^4
            const zx2 = izRe * izRe - izIm * izIm;
            const zy2 = 2.0 * izRe * izIm;
            const zx4 = zx2 * zx2 - zy2 * zy2;
            const zy4 = 2.0 * zx2 * zy2;

            // 3) apply forward Quad-Nova step on 1/z:
            //    f = (4/3)*(1/z) - (1/3)*(1/z)^4 + c*s
            const fRe = 1.3333333333333333 * izRe
                - 0.3333333333333333 * zx4
                + ccx;
            const fIm = 1.3333333333333333 * izIm
                - 0.3333333333333333 * zy4
                + ccy;

            // 4) invert back: z_{n+1} = 1 / f
            const den = 1.0 / (fRe * fRe + fIm * fIm + 1e-9);
            nx = fRe * den;
            ny = -fIm * den;
            break;
        }

        case 43: {  // Nova  2
            // 1) build z¬≤ and z‚Å¥ just like case 40
            const zx2 = qx * qx - qy * qy;
            const zy2 = 2.0 * qx * qy;
            const zx4 = zx2 * zx2 - zy2 * zy2;
            const zy4 = 2.0 * zx2 * zy2;

            // 2) do the forward Quad-Nova step f(z) = (4/3)z ‚Äì (1/3)z‚Å¥ + c¬∑s
            const fRe = 1.3333333333333333 * qx
                - 0.3333333333333333 * zx4
                + ccx;
            const fIm = 1.3333333333333333 * qy
                - 0.3333333333333333 * zy4
                + ccy;

            // 3) invert that result: z_{n+1} = 1 / f
            const invR2 = 1.0 / (fRe * fRe + fIm * fIm + 1e-9);
            nx = fRe * invR2;
            ny = -fIm * invR2;
            break;
        }

        case 44: { // Quartic-Nova: Newton iteration for z‚Å¥ ‚Äì 1 (plus c)
            // First build z¬≤ and z¬≥
            const zx2 = qx * qx - qy * qy;
            const zy2 = 2 * qx * qy;
            const zx3 = zx2 * qx - zy2 * qy;
            const zy3 = zx2 * qy + zy2 * qx;

            // Now z‚Å¥ = z¬≥ * z
            const zx4 = zx3 * qx - zy3 * qy;
            const zy4 = zx3 * qy + zy3 * qx;

            // Newton step: (z‚Å¥ ‚Äì 1) / (4 z¬≥)
            const numx = zx4 - 1.0, numy = zy4;
            const denx = 4.0 * (zx2 * qx - zy2 * qy);
            const deny = 4.0 * (zx2 * qy + zy2 * qx);
            const den2 = denx * denx + deny * deny + 1e-9; // avoid /0

            const divx = (numx * denx + numy * deny) / den2;
            const divy = (numy * denx - numx * deny) / den2;

            // new z = z ‚Äì (z‚Å¥‚Äì1)/(4 z¬≥) + c
            nx = qx - divx + ccx;
            ny = qy - divy + ccy;
            break;
        }
        case 45: { // Flower Nova
            // seed z‚ÇÄ = c
            if (iter === 0) {
                qx = cx;
                qy = cy;
            }

            // 1) build z¬≤
            const zx2 = qx * qx - qy * qy;
            const zy2 = 2.0 * qx * qy;

            // 2) build z¬≥ & z‚Å¥
            const zx3 = zx2 * qx - zy2 * qy;
            const zy3 = zx2 * qy + zy2 * qx;
            const zx4 = zx3 * qx - zy3 * qy;
            const zy4 = zx3 * qy + zy3 * qx;

            // 3) Newton-style divisor = 4 z¬≥
            const denx = 4.0 * zx3, deny = 4.0 * zy3;
            const den2 = denx * denx + deny * deny + 1e-9;

            // 4) numerator = z‚Å¥ ‚Äì 1
            const numx = zx4 - 1.0, numy = zy4;

            // 5) (z‚Å¥‚Äì1)/(4z¬≥)
            const divx = (numx * denx + numy * deny) / den2;
            const divy = (numy * denx - numx * deny) / den2;

            // 6) forward candidate: z‚Çô ‚Äì (z‚Å¥‚Äì1)/(4z¬≥) + c¬∑s
            const fx = qx - divx + ccx;
            const fy = qy - divy + ccy;

            // 7) NEGATE the result
            nx = -fx;
            ny = -fy;
            break;
        }
        case 46: {  // Scatter-Nova 
            // seed z‚ÇÄ = c exactly once
            if (iter === 0) {
                qx = cx;
                qy = cy;
            }

            // build z¬≤
            const zx2 = qx * qx - qy * qy;
            const zy2 = 2.0 * qx * qy;

            // build z¬≥ and z‚Å¥
            const zx3 = zx2 * qx - zy2 * qy;
            const zy3 = zx2 * qy + zy2 * qx;
            const zx4 = zx3 * qx - zy3 * qy;
            const zy4 = zx3 * qy + zy3 * qx;

            // denominator = 4¬∑z¬≥
            const denx = 4.0 * zx3, deny = 4.0 * zy3;
            const den2 = denx * denx + deny * deny + 1e-9; // avoid /0

            // numerator = z‚Å¥ ‚Äì 1
            const numx = zx4 - 1.0, numy = zy4;

            // (z‚Å¥‚Äì1)/(4 z¬≥)
            const divx = (numx * denx + numy * deny) / den2;
            const divy = (numy * denx - numx * deny) / den2;

            // forward Newton candidate: z ‚Äì (z‚Å¥‚Äì1)/(4 z¬≥) + c¬∑s
            const fx = qx - divx + ccx;
            const fy = qy - divy + ccy;

            // **invert** it: z‚Çô‚Çä‚ÇÅ = 1 / f
            const invR2 = 1.0 / (fx * fx + fy * fy + 1e-9);
            nx = fx * invR2;
            ny = -fy * invR2;
            break;
        }

        default: // Mandelbrot
            nx = qx * qx - qy * qy + ccx;
            ny = 2 * qx * qy + ccy;
    }

    return { nx, ny, npx, npy };
}
`;
    const workerURL = URL.createObjectURL(new Blob([workerSrc], { type: 'application/javascript' }));


    import * as THREE from 'three';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/OrbitControls.js';
    import { PointerLockControls } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/PointerLockControls.js';
    /* ------- constants (unchanged) ------- */
    let gridSize = 800, zMin = 0, zMax = 2, dz = .02, numLayers = Math.round((zMax - zMin) / dz) + 1, dx = 0, dy = 0;
    let ptsPerLayer = gridSize * gridSize, zoom = 4, escapeR = 4, maxIter = 100;
    let MAX_WORKERS = Math.max(navigator.hardwareConcurrency || 4, 4);
    let scaleM = 1;
    let totalPts = ptsPerLayer * numLayers;                  // initialise count s
    /* ------- UI refs ------- */
    const $ = id => document.getElementById(id);

    /* raw elements ---------------------------------------------------------- */
    const controlMode = $('controlMode');
    const fractalType = $('fractalType');
    const colorScheme = $('colorScheme');
    const alphaMode = $('alphaMode');
    const thresholdBasis = $('thresholdBasis');
    const lowThresh = $('lowThresh');
    const highThresh = $('highThresh');
    const lowVal = $('lowVal');
    const highVal = $('highVal');
    const clipX = $('clipX');
    const clipY = $('clipY');
    const clipZ = $('clipZ');
    const clipXVal = $('clipXVal');
    const clipYVal = $('clipYVal');
    const clipZVal = $('clipZVal');
    const layerVis = $('layerVis');
    const layerVal = $('layerVal');
    const ptSize = $('ptSize');
    const zScale = $('zScale'), zVal = $('zVal');
    const ptVal = $('ptVal');
    const loading = $('loading');
    const pGrid = $('pGrid');
    const pZmin = $('pZmin');
    const pZmax = $('pZmax');
    const pDz = $('pDz');
    const pZoom = $('pZoom');
    const pEsc = $('pEsc');
    const pIter = $('pIter');
    const pDx = $('pDx');
    const pDy = $('pDy');
    const applyParams = $('applyParams');
    const scaleMode = $('scaleMode');
    const resetAll = $('resetAll');
    const hueOffset = $('hueOffset');
    const hueOffsetVal = $('hueOffsetVal');
    const layerOffset = $('layerOffset');
    const layerOffsetVal = $('layerOffsetVal');
    const convergenceTest = $('convergence');

    let _hueAutoMode = 2;

    // make the label clickable
    hueOffsetVal.style.cursor = 'pointer';
    hueOffsetVal.title = 'Click to toggle hue animation:\n‚ñ∂ then ‚óÄ then ‚ñ†';

    // cycle mode on click
    hueOffsetVal.addEventListener('click', () => {
      _hueAutoMode = (_hueAutoMode + 1) % 3;
      // optional: change label color/icon based on mode
      switch (_hueAutoMode) {
        case 0: hueOffsetVal.textContent = hueOffset.value + '¬∞'; break;
        case 1: hueOffsetVal.textContent = hueOffset.value + '¬∞'; break;
        case 2: hueOffsetVal.textContent = hueOffset.value + '¬∞'; break;
      }
    });

    // const pJuliaMode = $('pJuliaMode'),
    //   pJuliaRe = $('pJuliaRe'),
    //   pJuliaIm = $('pJuliaIm');
    /* ------------------------------------------------------------------ *
     *  save each control‚Äôs initial value so we can return to it on Reset *
     * ------------------------------------------------------------------ */
    const defaults = {
      /* sliders -------------------------------------------------------- */
      low: +lowThresh.value,
      high: +highThresh.value,
      clipX: +clipX.value, clipY: +clipY.value, clipZ: +clipZ.value,
      layers: +layerVis.value,
      ptSize: +ptSize.value,
      zScale: +zScale.value,
      hueOffset: +hueOffset.value,
      /* render-parameter <input type="number"> fields ------------------ */
      grid: +pGrid.value,
      zMin: +pZmin.value, zMax: +pZmax.value, dz: +pDz.value,
      zoom: +pZoom.value, escR: +pEsc.value, iter: +pIter.value,
      dx: +pDx.value, dy: +pDy.value, scaleMode: +scaleMode.value,
      hueOffset: hueOffset.value,
      layers: +layerVis.value,
      layerOff: +layerOffset.value,
      convergenceTest: convergenceTest.checked
      // juliaMode: pJuliaMode.checked,
      // juliaRe: +pJuliaRe.value,
      // juliaIm: +pJuliaIm.value
    };

    function setSlider(sl, v) {
      sl.value = v;
      paintRange(sl);
    }

    /* ================================================================ *
 *  RESET ‚Ü©Ô∏é  ‚Äî restores every slider / number box to its default    *
 *  (keeps fractalType, colorScheme, alphaMode & thresholdBasis)    *
 * ================================================================ */
    resetAll.addEventListener('click', () => {

      /* sliders ------------------------------------------------------- */
      setSlider(lowThresh, defaults.low);
      setSlider(highThresh, defaults.high);
      setSlider(clipX, defaults.clipX);
      setSlider(clipY, defaults.clipY);
      setSlider(clipZ, defaults.clipZ);
      setSlider(layerVis, defaults.layers);
      setSlider(ptSize, defaults.ptSize);
      setSlider(zScale, defaults.zScale);
      setVisibleLayers(defaults.layers);      // sync geometry draw-range
      /* numeric render parameters ------------------------------------ */
      pGrid.value = defaults.grid;
      pZmin.value = defaults.zMin; pZmax.value = defaults.zMax; pDz.value = defaults.dz;
      pZoom.value = defaults.zoom; pEsc.value = defaults.escR; pIter.value = defaults.iter;
      pDx.value = defaults.dx; pDy.value = defaults.dy;
      scaleMode.value = defaults.scaleMode;
      setSlider(hueOffset, defaults.hueOffset); _hueAutoMode = 2;
      setSlider(layerOffset, defaults.layerOff);
      convergenceTest.checked = defaults.convergenceTest;
      // pJuliaMode.checked = defaults.juliaMode;
      // pJuliaRe.value = defaults.juliaRe;
      // pJuliaIm.value = defaults.juliaIm;
      /* update uniforms, ranges, on-screen numbers ------------------- */
      upd();

      /* rebuild scene with pristine render params -------------------- */
      gridSize = defaults.grid;
      zMin = defaults.zMin;
      zMax = defaults.zMax;
      dz = defaults.dz;
      zoom = defaults.zoom;
      escapeR = defaults.escR;
      maxIter = defaults.iter;
      dx = defaults.dx;
      dy = defaults.dy;
      camera.position.set(0, -zoom * 1.5, zoom);
      scaleM = defaults.scaleMode;

      rebuildScene();                // full recompute & redraw
    });


    /* keep the object exactly as you already had it ------------------------- */
    const ui = {
      fractal: fractalType, scheme: colorScheme, alpha: alphaMode, basis: thresholdBasis,
      low: lowThresh, high: highThresh, lowVal, highVal, hueOffset,
      clipX, clipY, clipZ, clipXVal, clipYVal, clipZVal,
      layerVis, layerVal, ptSize, ptVal, loading, pDx, pDy, scaleMode: scaleMode,
      pGrid, pZmin, pZmax, pDz, pZoom, pEsc, pIter, apply: applyParams, convergenceTest
    };
    /* ------- THREE setup (identical) ------- */
    let scene = new THREE.Scene();
    let camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, .1, 1000);
    camera.position.set(0, -zoom * 1.5, zoom);
    let renderer = new THREE.WebGLRenderer({ antialias: false });
    renderer.setSize(innerWidth, innerHeight);
    renderer.getContext().disable(renderer.getContext().CULL_FACE);
    document.body.appendChild(renderer.domElement);
    let controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true;

    /* ------- geometry buffers ------- */
    let posBuf = new Float32Array(totalPts * 3), ratBuf = new Float32Array(totalPts), lyrBuf = new Float32Array(totalPts);
    let geom = new THREE.BufferGeometry();
    geom.setAttribute('position', new THREE.BufferAttribute(posBuf, 3));
    geom.setAttribute('ratio', new THREE.BufferAttribute(ratBuf, 1));
    geom.setAttribute('layerIdx', new THREE.BufferAttribute(lyrBuf, 1));
    geom.setDrawRange(0, 0);

    /* ------- uniforms & shaders  ‚Äì same as before  ------- */
    const uniforms = {
      lowT: { value: +ui.low.value }, highT: { value: +ui.high.value },
      alphaMode: { value: +ui.alpha.value }, basis: { value: +ui.basis.value },
      scheme: { value: +ui.scheme.value },
      clipX: { value: +ui.clipX.value }, clipY: { value: +ui.clipY.value }, clipZ: { value: +ui.clipZ.value },
      worldCell: { value: zoom / (gridSize - 1) },
      pointScale: { value: +ui.ptSize.value },
      zGap: { value: +zScale.value },
      hueOffset: { value: 0.0 },
      viewport: { value: new THREE.Vector2(innerWidth, innerHeight) }
    };

    const mat = new THREE.ShaderMaterial({
      transparent: true, depthTest: true, depthWrite: true,
      blending: THREE.NormalBlending, uniforms,
      vertexShader:/* glsl */`
precision highp float;
attribute float ratio, layerIdx;
varying   float vR, vL;
varying   vec3  vW;
uniform float worldCell, pointScale, zGap;
uniform vec2  viewport;
void main () {
  vR = ratio;  vL = layerIdx;

  /* scale Z by the new uniform before anything else */
  
  vec3 pos = vec3(position.xy, position.z * zGap - zGap);
  vW = pos;

  vec4 mv = modelViewMatrix * vec4(pos, 1.0);
  float d = -mv.z;
  gl_PointSize = max(1.0,
                     worldCell * pointScale *
                     projectionMatrix[1][1] * viewport.y / d);
  gl_Position = projectionMatrix * mv;
}`,
      fragmentShader: /* glsl */`
precision highp float;

varying vec3  vW;
varying float vR, vL;

uniform float lowT, highT;
uniform int   alphaMode, basis, scheme;
uniform float clipX, clipY, clipZ, worldCell, zGap;
uniform float hueOffset;
/* ---------- helpers ---------- */
vec3 hsl2rgb (vec3 hsl) {
  float H = hsl.x, S = hsl.y, L = hsl.z;
  float C = (1.0 - abs(2.0 * L - 1.0)) * S;
  float X = C * (1.0 - abs(mod(H * 6.0, 2.0) - 1.0));
  float m = L - 0.5 * C;
  vec3  rgb =
        (H < 1.0/6.0) ? vec3(C, X, 0.0) :
        (H < 2.0/6.0) ? vec3(X, C, 0.0) :
        (H < 3.0/6.0) ? vec3(0.0, C, X) :
        (H < 4.0/6.0) ? vec3(0.0, X, C) :
        (H < 5.0/6.0) ? vec3(X, 0.0, C) :
                         vec3(C, 0.0, X);
  return rgb + m;
}

/* disengages when slider ‚âà 2.0 */
float clipGate (float coord, float cut) {
  return (cut >= 1.999)
       ? 1.0
       : smoothstep(cut, cut - worldCell, coord);
}

/* ---------- main ---------- */
void main () {
  float a = 1.0;
  if (alphaMode == 1)      a = vR;
  else if (alphaMode == 2) a = 1.0 - vR;

  /* apply X/Y/Z clip gates */
  a *= clipGate(vW.x, clipX)
     * clipGate(vW.y, clipY)
     * clipGate(vW.z / zGap + 1.0, clipZ);

  float val = (basis == 1 ? vL : vR);
  if (val < lowT || val > highT || a < 0.01) discard;

  float r = vR, H, L;


      if(scheme==0){                       /* Violet-Cyan-White */
        H = (260.0 - 260.0*pow(r,0.9)) / 360.0;
        L = (10.0  + 65.0 *pow(r,1.2)) / 100.0;

      }else if(scheme==1){                 /* Fire */
        H = ( 0.0 + 60.0*r) / 360.0;
        L = 0.50 + 0.50*r;

      }else if(scheme==2){                 /* Ice */
        H = (200.0 - 100.0*r) / 360.0;
        L = 0.30 + 0.70*r;

      }else if(scheme==3){                 /* Sunset */
        H = ( 30.0 + 270.0*r) / 360.0;
        L = 0.30 + 0.40*r;

      }else if(scheme==4){                 /* Forest */
        H = (120.0 -  90.0*r) / 360.0;
        L = 0.20 + 0.50*r;

      }else if(scheme==5){                 /* Neon */
        H = (300.0 - 240.0*r) / 360.0;
        L = 0.55 + 0.20*sin(r*3.14159);

      }else if(scheme==6){                 /* Grayscale */
        gl_FragColor = vec4(vec3(r), a);
        return;

      /* --- retuned Inferno (dark purple ‚Üí red ‚Üí gold, no green cast) --- */
      }else if(scheme==7){
        H = (10.0 + 60.0*pow(r,1.2)) / 360.0;   // 10¬∞‚Üí70¬∞
        L = 0.15 + 0.75*pow(r,1.5);

      /* --- rainbow & pastel gimmicks --- */
      }else if(scheme==8){                      /* Rainbow 360¬∞ */
        H = r;
        L = 0.45 + 0.25*(1.0 - r);

      }else if(scheme==9){                      /* Rainbow 720¬∞ */
        H = mod(2.0*r, 1.0);
        L = 0.50;

      }else if(scheme==10){                     /* Pastel loop */
        H = mod(3.0*r + 0.1, 1.0);
        L = 0.65;

      }else if(scheme==11){                     /* Viridis-ish */
        H = 0.75 - 0.55*r;                      // 270¬∞‚Üí72¬∞
        L = 0.25 + 0.55*r*r;

      /* --- NEW darker / cooler palettes --- */
      }else if(scheme==12){                     /* Magma */
        H = (5.0 + 70.0*r) / 360.0;             // deep plum ‚Üí yellow-orange
        L = 0.10 + 0.80*pow(r,1.4);

      }else if(scheme==13){                     /* Plasma */
        H = (260.0 - 260.0*r) / 360.0;          // purple ‚Üí yellow
        L = 0.30 + 0.60*pow(r,0.8);

      }else if(scheme==14){                     /* Cividis */
        H = (230.0 - 160.0*r) / 360.0;          // blue-green ‚Üí orange
        L = 0.25 + 0.60*r;

      }else if(scheme==15){                     /* Ocean */
        H = (200.0 + 40.0*r) / 360.0;           // teal ‚Üí azure
        L = 0.20 + 0.50*r;

      }else if(scheme==16){                     /* Midnight Blue */
        H = 0.6;                               // ~250¬∞
        L = 0.15 + 0.35*r;

      }else if(scheme==17){                     /* Cool-Warm diverging */
        H = r < 0.5
            ? mix(0.55, 0.75, r*2.0)            // cyan-blue branch
            : mix(0.02, 0.11, (r-0.5)*2.0);     // orange-red branch
        L = 0.25 + 0.55*abs(r-0.5);

      /* fallback: old Inferno-style if scheme out of range */
      }
      else if (scheme == 18) {                    /* Rainbow 1080¬∞ (3 loops) */
        H = mod(r * 3.0, 1.0);
        L = 0.50 + 0.25*(1.0 - r);
      }
      else if (scheme == 19) {                    /* Rainbow 1440¬∞ (4 loops) */
        H = mod(r * 4.0, 1.0);
        L = 0.50;
      }
      else if (scheme == 20) {                    /* Pastel 5-loop */
        H = mod(r * 5.0 + 0.2, 1.0);
        L = 0.65;
      }
      else if (scheme == 21) {                    /* Thermal (blue‚Üíred) */
        H = (240.0 - 240.0 * r) / 360.0;
        L = 0.30 + 0.40 * r;
      }
      else if (scheme == 22) {                    /* Turbulent wave */
        H = mod(r * 6.0 + sin(r * 10.0), 1.0);
        L = 0.40 + 0.30 * sin(r * 20.0);
      }
      else if (scheme == 23) {                    /* Autumn (gold‚Üírust) */
        H = (30.0 + 50.0 * r) / 360.0;
        L = 0.45 + 0.30 * r;
      }
      else if (scheme == 24) {                    /* Spring (emerald‚Üírose) */
        H = (90.0 - 80.0 * r) / 360.0;
        L = 0.50 + 0.40 * r;
      }
      else if (scheme == 25) {                    /* Summer (lime‚Üíteal) */
        H = (100.0 - 100.0 * r) / 360.0;
        L = 0.40 + 0.50 * r;
      }
      else if (scheme == 26) {                    /* Mono-loop (10√ó grayscale flicker) */
        float loop = mod(r * 10.0, 1.0);
        float L = loop * 0.8;
        // zero saturation ‚Üí grayscale
        vec3 col = hsl2rgb(vec3(0.0, 0.0, L));
        gl_FragColor = vec4(col, a);
        return;
      }
      else if (scheme == 27) {                    /* High-contrast diverging */
        H = r < 0.5
            ? mix(0.80, 0.40, r * 2.0)
            : mix(0.10, 0.00, (r - 0.5) * 2.0);
        L = 0.20 + 0.60 * abs(r - 0.5);
      }
      else if (scheme == 28) {                    /* Sine-wave hue */
        H = mod(sin(r * 6.28318) * 0.5 + 0.5, 1.0);
        L = 0.50;
      }
      else if (scheme == 29) {                    /* Sawtooth loop (3√ó) */
        H = fract(r * 3.0);
        L = fract(r * 3.0);
      }
      else if (scheme == 30) {                    /* Rainbow 2160¬∞ (6 loops) */
        H = mod(r * 6.0, 1.0);
        // pulsating brightness every half-loop
        L = 0.45 + 0.40 * abs(sin(r * 6.0 * 3.14159));
      }
      else if (scheme == 31) {                    /* Triangle-wave 8 loops */
        float t = fract(r * 8.0);
        // ramp up then down each loop
        H = t < 0.5
            ? (t * 2.0)
            : (1.0 - t) * 2.0;
        // dip in the middle of each cycle
        L = 0.60 - 0.30 * abs(t - 0.5);
      }
      else if (scheme == 32) {                    /* Exponential 12 loops */
        H = mod(pow(r, 0.7) * 12.0, 1.0);
        // slow fade-in, sharp fall-off
        L = 0.50 + 0.30 * pow(r, 1.2);
      }
      else if (scheme == 33) {                    /* Sawtooth 10 loops + offset */
        H = fract(r * 10.0 + 0.3);
        // linear brightening
        L = 0.40 + 0.50 * r;
      }
      else{
        H = (40.0 + 310.0*pow(r,1.3)) / 360.0;
        L = 0.20 + 0.50*pow(r,0.8);
      }
      H = mod(H + hueOffset, 1.0);
      vec3 col = hsl2rgb(vec3(H, 1.0, L));
      gl_FragColor = vec4(col, a);
}`
    });
    let points = new THREE.Points(geom, mat);
    points.frustumCulled = false;          // keep everything visible for now
    scene.add(points);

    /* ------- UI ‚Üí uniforms ------- */
    function upd() {
      uniforms.lowT.value = +ui.low.value; ui.lowVal.textContent = (+ui.low.value).toFixed(2);
      uniforms.highT.value = +ui.high.value; ui.highVal.textContent = (+ui.high.value).toFixed(2);
      uniforms.alphaMode.value = +ui.alpha.value;
      uniforms.basis.value = +ui.basis.value;
      uniforms.scheme.value = +ui.scheme.value;
      uniforms.hueOffset.value = +hueOffset.value / 360.0;
      hueOffsetVal.textContent = hueOffset.value + '¬∞';
      uniforms.clipX.value = +ui.clipX.value; ui.clipXVal.textContent = (+ui.clipX.value).toFixed(2);
      uniforms.clipY.value = +ui.clipY.value; ui.clipYVal.textContent = (+ui.clipY.value).toFixed(2);
      uniforms.clipZ.value = +ui.clipZ.value; ui.clipZVal.textContent = (+ui.clipZ.value).toFixed(2);
      uniforms.zGap.value = +zScale.value; zVal.textContent = (+zScale.value).toFixed(2);
      uniforms.pointScale.value = +ui.ptSize.value; ui.ptVal.textContent = (+ui.ptSize.value).toFixed(2);
    }
    [ui.low, ui.high, ui.alpha, ui.basis, ui.scheme,
    ui.clipX, ui.clipY, ui.clipZ, ui.hueOffset,
    ui.ptSize, zScale].forEach(e => e.addEventListener('input', upd));
    upd();

    ui.layerVis.addEventListener('input', () => setVisibleLayers(+ui.layerVis.value));
    /* keep slider in-step with geometry draw-range */
    function setVisibleLayers(n) {
      const count = Math.max(1, +layerVis.value | 0);
      const offset = Math.min(+layerOffset.value | 0, numLayers - count);

      // update slider bounds & labels
      layerOffset.max = Math.max(0, numLayers - count);
      layerVis.value = count; paintRange(layerVis);
      layerVal.textContent = count;
      layerOffset.value = offset; paintRange(layerOffset);
      layerOffsetVal.textContent = offset;

      // draw only [offset .. offset+count)
      const startIndex = offset * ptsPerLayer;
      const drawCount = count * ptsPerLayer;
      geom.setDrawRange(startIndex, drawCount);
    }


    layerVis.addEventListener('input', setVisibleLayers);
    layerOffset.addEventListener('input', setVisibleLayers);


    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ render-parameter ‚ÄúApply‚Äù button ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    ui.apply.addEventListener('click', () => {
      gridSize = +ui.pGrid.value | 0;
      zMin = +ui.pZmin.value;
      zMax = +ui.pZmax.value;
      dz = +ui.pDz.value;
      zoom = +ui.pZoom.value;
      escapeR = +ui.pEsc.value;
      maxIter = +ui.pIter.value;
      dx = +ui.pDx.value;
      dy = +ui.pDy.value;
      camera.position.set(0, -zoom * 1.5, zoom);
      scaleM = +ui.scaleMode.value;
      rebuildScene();
    });

    /* WASD state ---------------------------------------------------------- */
    const move = { f: 0, b: 0, l: 0, r: 0 };   // forward/back/left/right flags
    const WALK_SPEED = 4;                  // units - per - second (tweak!)
    const fpsControls = new PointerLockControls(camera, renderer.domElement);
    let inFPS = false;          // current mode flag

    /* ‚îÄ‚îÄ‚îÄ keyboard shortcuts for five sliders ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    const binds = [
      /* Low Œ±  ‚Äì Q / E */
      {
        inc: 'KeyQ', dec: 'KeyE', el: lowThresh, step: +lowThresh.step || 0.01,
        after: () => { paintRange(lowThresh); upd(); }
      },

      /* High Œ± ‚Äì G / F */
      {
        inc: 'KeyG', dec: 'KeyF', el: highThresh, step: +highThresh.step || 0.01,
        after: () => { paintRange(highThresh); upd(); }
      },

      /* Visible layers ‚Äì V / B   (unique keys now) */
      {
        inc: 'KeyV', dec: 'KeyB', el: layerVis, step: +layerVis.step || 1,
        after: () => { setVisibleLayers(+layerVis.value); paintRange(layerVis); }
      },

      /* Point size ‚Äì X / Z */
      {
        inc: 'KeyX', dec: 'KeyZ', el: ptSize, step: +ptSize.step || 0.05,
        after: () => { paintRange(ptSize); upd(); }
      },

      /* Z-spacing ‚Äì M / N  (unchanged) */
      {
        inc: 'KeyM', dec: 'KeyN', el: zScale, step: +zScale.step || 0.1,
        after: () => { paintRange(zScale); upd(); }
      }
    ];


    /* ‚ù∂  Robust slider update ‚Äî never lets High ‚â§ Low  -------------------- */
    function nudgeSlider(sl, delta) {
      const step = +sl.step || 0.01,
        min = +sl.min,
        max = +sl.max;

      /* snap to the slider‚Äôs own grid */
      let val = +sl.value + delta;
      val = Math.round(val / step) * step;
      val = Math.min(max, Math.max(min, val));

      /* ------------------------------------------------------------------ */
      if (sl === lowThresh) {                    /* editing LOW Œ± ---------- */
        /* if we collide with High Œ± ‚Üí nudge High upward */
        if (val > +highThresh.value - step) {
          highThresh.value = (val + step).toFixed(2);
          paintRange(highThresh);
        }
      } else if (sl === highThresh) {            /* editing HIGH Œ± --------- */
        /* if we collide with Low Œ± ‚Üí nudge Low downward */
        if (val < +lowThresh.value + step) {
          lowThresh.value = (val - step).toFixed(2);
          paintRange(lowThresh);
        }
      }

      /* write the new value and refresh */
      sl.value = val.toFixed(step < 1 ? 2 : 0);
      paintRange(sl);
      upd();
    }

    /* ‚ù∑  Fixed-rate key repeat (no OS acceleration) ----------------------- */
    const timers = new Map();           // keyCode ‚Üí intervalID

    function startRepeat(code, bind, dir) {
      if (timers.has(code)) return;     // already running
      // first tick immediately
      nudgeSlider(bind.el, dir * bind.step); bind.after();
      // then steady 16 Hz repeat
      timers.set(code, setInterval(() => {
        nudgeSlider(bind.el, dir * bind.step);
        bind.after();
      }, 62.5));
    }
    function stopRepeat(code) {
      clearInterval(timers.get(code));
      timers.delete(code);
    }

    /* ‚ù∏  Key handlers ----------------------------------------------------- */
    addEventListener('keydown', e => {
      for (const b of binds) {
        if (e.code === b.inc) startRepeat(e.code, b, +1);
        if (e.code === b.dec) startRepeat(e.code, b, -1);
      }
      if (!e.repeat) {
        if (e.code === 'KeyW') move.f = 1;
        if (e.code === 'KeyS') move.b = 1;
        if (e.code === 'KeyA') move.l = 1;
        if (e.code === 'KeyD') move.r = 1;
        if (e.code === 'Escape' && inFPS) fpsControls.unlock();
      }
      if (!inFPS && (move.f || move.b || move.l || move.r)) {
        controls.enabled = false;
        fpsControls.lock();
      }
    });

    addEventListener('keyup', e => {
      stopRepeat(e.code);               // stop slider auto-repeat
      if (e.code === 'KeyW') move.f = 0;
      if (e.code === 'KeyS') move.b = 0;
      if (e.code === 'KeyA') move.l = 0;
      if (e.code === 'KeyD') move.r = 0;
    });



    fpsControls.addEventListener('lock', () => {
      inFPS = true;
      controls.enabled = false;        // freeze orbit while in FPS
    });
    fpsControls.addEventListener('unlock', () => {
      controls.enabled = true;
      inFPS = false;
    });




    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ build / rebuild helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

    function buildGeometry() {
      recalcDerived();

      posBuf = new Float32Array(totalPts * 3);
      ratBuf = new Float32Array(totalPts);
      lyrBuf = new Float32Array(totalPts);

      geom = new THREE.BufferGeometry();
      geom.setAttribute('position', new THREE.BufferAttribute(posBuf, 3));
      geom.setAttribute('ratio', new THREE.BufferAttribute(ratBuf, 1));
      geom.setAttribute('layerIdx', new THREE.BufferAttribute(lyrBuf, 1));
      geom.setDrawRange(0, 0);               // invisible until we animate

      points = new THREE.Points(geom, mat);
      points.frustumCulled = false;
    }

    function rebuildScene() {
      scene.remove(points);
      mat.dispose();
      geom.dispose();

      buildGeometry();
      scene.add(points);

      uniforms.worldCell.value = zoom / (gridSize - 1);

      revealStarted = false;
      revealPts = 0;

      compute();                              // restart worker pipeline
    }

    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ reveal / wipe-on state ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    let revealStarted = false;
    let revealPts = 0; let revealRate = 0;                 // points-per-second; set later
    function recalcDerived() {
      numLayers = Math.round((zMax - zMin) / dz) + 1;
      ptsPerLayer = gridSize * gridSize;
      totalPts = ptsPerLayer * numLayers;
      ui.layerVis.max = numLayers;
      ui.layerVis.min = 1;
      ui.layerVis.value = numLayers;
      ui.layerVal.textContent = numLayers;
      layerOffset.max = Math.max(0, numLayers - +layerVis.value);
      layerOffset.value = Math.min(+layerOffset.value, layerOffset.max);
      layerOffsetVal.textContent = layerOffset.value;
      paintRange(layerOffset);
    }


    function finalizeGeometry() {
      geom.attributes.position.needsUpdate = true;
      geom.attributes.ratio.needsUpdate = true;
      geom.attributes.layerIdx.needsUpdate = true;
      ui.layerVis.value = numLayers;
      ui.layerVal.textContent = numLayers;

      ui.loading.style.display = 'none';
      revealStarted = true;                  // start wipe-on next frame
      revealPts = 0;
      revealRate = ptsPerLayer * 30;          // ‚âà 6 layers-worth per second
      geom.setDrawRange(0, 0);
    }

    /* ------- build pool & compute ------- */
    let nextK = 0, done = 0, curFrac = +ui.fractal.value;

    function launch() {
      if (nextK >= numLayers) return;

      const k = nextK++;
      const w = new Worker(workerURL);

      w.postMessage({
        gridSize, k, zMin, dz, zoom, escapeR, maxIter, dx, dy,
        fractalType: curFrac, scaleMode: scaleM, convergenceTest:convergenceTest.checked
        // juliaMode: +pJuliaMode.checked,
        // juliaRe: +pJuliaRe.value,
        // juliaIm: +pJuliaIm.value,
      });

      w.onmessage = ({ data: { k, pos, rat } }) => {
        const p = new Float32Array(pos);
        const r = new Float32Array(rat);

        const offPts = k * ptsPerLayer;
        posBuf.set(p, offPts * 3);
        ratBuf.set(r, offPts);
        lyrBuf.fill(k / (numLayers - 1), offPts, offPts + ptsPerLayer);

        done++;
        ui.loading.textContent = `Loading layers: ${done} / ${numLayers}`;

        w.terminate();
        launch();                             // next slice

        if (done === numLayers) finalizeGeometry();
      };
    }

    function compute() {
      posBuf.fill(0);
      ratBuf.fill(0);
      lyrBuf.fill(0);

      nextK = done = 0;
      curFrac = +ui.fractal.value;

      geom.setDrawRange(0, 0);
      ui.loading.style.display = 'block';
      ui.loading.textContent = `Loading layers: 0 / ${numLayers}`;

      for (let i = 0; i < MAX_WORKERS; i++) launch();
    }
    compute();
    // ui.fractal.addEventListener('change', compute);

    /* ------- animation loop & resize ------- */
    let last = performance.now();
    (function anim() {
      requestAnimationFrame(anim);

      const now = performance.now();
      const dt = (now - last) / 1000;     // seconds
      last = now;

      if (revealStarted && revealPts < totalPts) {
        revealPts = Math.min(totalPts, revealPts + revealRate * dt);
        geom.setDrawRange(0, revealPts | 0);
      }

      if (_hueAutoMode !== 2) {
        // step size (degrees per frame) ‚Äî adjust as you like
        const step = 1;
        let v = +hueOffset.value;
        v = (v + (_hueAutoMode === 0 ? +step : -step) + 360) % 360;
        hueOffset.value = v;
        upd();
      }

      /* --- positional WASD in whichever mode we're in --- */
      if (move.f || move.b || move.l || move.r) {
        const step = WALK_SPEED * dt;

        let fwd = new THREE.Vector3();
        if (inFPS) {
          //  pointer-lock: forward = camera‚Äôs current look direction
          fpsControls.getDirection(fwd);   // unit vector
        } else {
          //  orbit: forward toward the target point
          fwd.subVectors(controls.target, camera.position).normalize();
        }
        const right = new THREE.Vector3().crossVectors(fwd, camera.up).normalize();

        const delta = new THREE.Vector3()
          .addScaledVector(fwd, step * (move.f - move.b))
          .addScaledVector(right, step * (move.r - move.l));

        camera.position.add(delta);
        if (!inFPS) controls.target.add(delta);   // keep dolly motion in orbit mode
      }

      if (!inFPS) controls.update();
      renderer.render(scene, camera);
    }());

    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      uniforms.viewport.value.set(innerWidth, innerHeight);
    });
  </script>
</body>

</html>